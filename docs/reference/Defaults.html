<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Default Parameter Settings and Handling Functions — Defaults • sos4R</title>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- sticky kit -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>



<meta property="og:title" content="Default Parameter Settings and Handling Functions — Defaults" />

<meta property="og:description" content="These values are default parameters and handling functions for connections and requests to, as well as response processing of ansers from, Sensor Observation Services. These allow to simplify a SOS connection for the most common use cases and non-expert users." />
<meta name="twitter:card" content="summary" />



<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">sos4R</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.3.0.9042</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/01-quickstart.html">sos4R: Accessing Sensor Observation Services from R -- Quickstart</a>
    </li>
    <li>
      <a href="../articles/02-ogc-sos.html">sos4R: OGC SWE and SOS</a>
    </li>
    <li>
      <a href="../articles/03-sos-operations.html">sos4R: SOS Operations</a>
    </li>
    <li>
      <a href="../articles/04-extensions.html">sos4R: Extending package functions and advanced configuration</a>
    </li>
  </ul>
</li>
<li>
  <a href="../DEV-README.html">Developer Docs</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/52North/sos4R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Default Parameter Settings and Handling Functions</h1>
    
    <div class="hidden name"><code>Defaults.Rd</code></div>
    </div>

    <div class="ref-description">
    
    <p>These values are default parameters and handling functions for connections and requests to, as well as response processing of ansers from, Sensor Observation Services. These allow to simplify a SOS connection for the most common use cases and non-expert users.</p>
    
    </div>

    <pre class="usage"><span class='fu'>SosDefaultBinding</span>()

<span class='fu'>SosParsingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))
<span class='fu'>SosEncodingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))
<span class='fu'>SosDataFieldConvertingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))

<span class='fu'>SosDisabledParsers</span>()

<span class='fu'>SosExampleServices</span>()

<span class='fu'>SosDefaults</span>()

<span class='fu'>SosResetParsingFunctions</span>(<span class='no'>sos</span>)

<span class='fu'>SosDefaultDCPs</span>()

<span class='fu'>SosDefaultParsingOptions</span>()</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>&#8230;</th>
      <td><p>Named references to functions to be used for the respective element during parsing, encoding oder conversion, e.g. <code>"myUnit" = myUnitParser</code>.</p></td>
    </tr>
    <tr>
      <th>include</th>
      <td><p>A list of names of elements whose functions shall be included in the returned list, e.g. <code>include = c("GetObservation", "DescribeSensor")</code>. This inclusion is done <b>after</b> replacing the default functions based on the <code>...</code> argument.</p></td>
    </tr>
    <tr>
      <th>exclude</th>
      <td><p>A list of names of elements whose functions shall be excluced in the returned list, e.g. <code>exclude = c("DescribeSensor")</code>. This exclusion is done <b>after</b> replacing the default functions based on the <code>...</code> argument.</p></td>
    </tr>
    <tr>
      <th>sos</th>
      <td><p>An object of class <code>SOS</code>.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The default values are strongly related to what is actually implemented in the package, but also often resemble the (hopefully) most common use cases.</p>
<p>Some defaults are accessed directly, others should be accessed using a function. The latter is required for cases where a runtime evaluation is needed, e.g. for default values of construction functions.</p>
<p>A special case are the functions to access the default functions for specific purposes, which are the parsing functions, the encoding functions and the field converting functions. See the examples on how to use them.</p>
<p>The function <code>SosDisabledParsers</code> can be used to use no parsing at all (despite the parsing for the capabilities response, which is required for establishing a connection to a SOS. This function is helpful to inspect the unprocessed responses from a service.</p>
<p>The function <code>SosResetParsingFunctions</code> can be used to replace the included parsing functions of a <code>SOS</code> object with the default ones. This is even useful for development of the default parsing functions.</p>
<p><b>The default parameter values are:</b></p><dl class='dl-horizontal'>
	<dt>sosDefaultCharacterEncoding</dt><dd><p><code>\Sexpr[results=verbatim,stage=render]{sosDefaultCharacterEncoding}</code></p></dd> % "UTF-8"
	<dt>sosDefaultDescribeSensorOutputFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultDescribeSensorOutputFormat}</code></p></dd> % SosSupportedResponseFormats()[2]
	<dt>sosDefaultGetCapSections</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapSections}</code></p></dd> % c("All")
	<dt>sosDefaultGetCapAcceptFormats</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapAcceptFormats}</code></p></dd> % c("text/xml")
	<dt>sosDefaultGetCapOwsVersion</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapOwsVersion}</code></p></dd> % "1.1.0"
	<dt>sosDefaultGetObsResponseFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetObsResponseFormat}</code></p></dd> % SosSupportedResponseFormats()[1]
	<dt>sosDefaultTimeFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTimeFormat}</code></p></dd> % "%Y-%m-%dT%H:%M:%OS"
	<dt>sosDefaultFilenameTimeFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultFilenameTimeFormat}</code></p></dd> %
	<dt>sosDefaultTempOpPropertyName</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTempOpPropertyName}</code></p></dd> % "om:samplingTime"
	<dt>sosDefaultTemporalOperator</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTemporalOperator}</code></p></dd> % SosSupportedTemporalOperators()[[ogcTempOpTMDuringName]]
	<dt>sosDefaultSpatialOpPropertyName</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultSpatialOpPropertyName}</code></p></dd> % "urn:ogc:data:location"
</dl>
    <p>The <b>default parsing functions</b> can be replaced for a variety of XML elements, so that you only need to replace the parts of the parsing that really must be changed. Be aware that inclusion and exclusion are performed after merging the given functions with the defaults!</p>
<p><b>Example Services:</b> This list contains a few SOS instances that were tested (to different degress) with <span class="pkg">sos4R</span>. The package authors do not maintain these services, so no guarantee can be given that these are usable.</p>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The default value of the respective setting or parameter. This can be a list, especially a named list of functions.</p>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p><code><a href='Constants.html'>Constants</a></code></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># simple default values</span>
<span class='fu'>show</span>(<span class='no'>sosDefaultCharacterEncoding</span>)</div><div class='output co'>#&gt; [1] "UTF-8"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultDescribeSensorOutputFormat</span>)</div><div class='output co'>#&gt; [1] "text/xml;subtype=\"sensorML/1.0.1\""</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapAcceptFormats</span>)</div><div class='output co'>#&gt; [1] "text/xml"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapOwsVersion</span>)</div><div class='output co'>#&gt; [1] "1.1.0"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapSections</span>)</div><div class='output co'>#&gt; [1] "All"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetObsResponseFormat</span>)</div><div class='output co'>#&gt; [1] "text/xml;subtype=\"om/1.0.0\""</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultSpatialOpPropertyName</span>)</div><div class='output co'>#&gt; [1] "urn:ogc:data:location"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTempOpPropertyName</span>)</div><div class='output co'>#&gt; [1] "om:samplingTime"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTemporalOperator</span>)</div><div class='output co'>#&gt; [1] "TM_During"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTimeFormat</span>)</div><div class='output co'>#&gt; [1] "%Y-%m-%dT%H:%M:%OS"</div><div class='input'><span class='fu'>SosDefaultBinding</span>()</div><div class='output co'>#&gt; [1] "POX"</div><div class='input'>
</div><span class='co'># NOT RUN {</span>
<span class='co'># usage of defaults in construction method for SOS class</span>
<span class='no'>sos</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='SOS.html'>SOS</a></span>(<span class='st'>"http://mysos.com/sos"</span>, <span class='kw'>binding</span> <span class='kw'>=</span> <span class='fu'>SosDefaultBinding</span>(),
                <span class='kw'>timeFormat</span> <span class='kw'>=</span> <span class='no'>sosDefaultTimeFormat</span>)
<span class='co'># }</span><div class='input'>
<span class='co'># functions to disable all parsing</span>
<span class='fu'>SosDisabledParsers</span>()</div><div class='output co'>#&gt; $GetCapabilities
#&gt; function (obj, sos) 
#&gt; {
#&gt;     if (sos@version == sos100_version) {
#&gt;         .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;     }
#&gt;     else if (sos@version == sos200_version) {
#&gt;         .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function (obj) 
#&gt; {
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservation
#&gt; function (obj) 
#&gt; {
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function (obj) 
#&gt; {
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function (obj) 
#&gt; {
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
<span class='co'># Replace a parsing function</span>
<span class='no'>myER</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>xml</span>) {
        <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/function'>return</a></span>(<span class='st'>"EXCEPTION!!!11"</span>)
}
<span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>)</div><div class='output co'>#&gt; $ExceptionReport
#&gt; function (xml) 
#&gt; {
#&gt;     return("EXCEPTION!!!11")
#&gt; }
#&gt; &lt;environment: 0xcffa6a8&gt;
#&gt; 
#&gt; $GetCapabilities
#&gt; function (obj, sos) 
#&gt; {
#&gt;     if (sos@version == sos100_version) {
#&gt;         .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;     }
#&gt;     else if (sos@version == sos200_version) {
#&gt;         .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Starting... \n")
#&gt;     .id &lt;- .smlIdentifier(obj, "uniqueID", verbose = verbose)
#&gt;     .shortName &lt;- .smlIdentifier(obj, "shortName", verbose = verbose)
#&gt;     .descrNode &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathDescription, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .description &lt;- xml2::xml_text(x = .descrNode)
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Got ID", .id, "and shortName", .shortName, 
#&gt;             "and description", .description, "\n")
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Parsing boundedBy from", .smlXPathObservedBBox, 
#&gt;             "\n")
#&gt;     .observedBBox &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathObservedBBox, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.observedBBox)) {
#&gt;         .referenceFrame &lt;- xml2::xml_attr(x = .observedBBox, 
#&gt;             attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;         .llVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox, 
#&gt;             search = paste0(sweUpperCornerName, "/", sweVectorName), 
#&gt;             ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;         .uuVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox, 
#&gt;             search = paste0(sweLowerCornerName, "/", sweVectorName), 
#&gt;             ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;         .bb &lt;- matrix(c(.llVector[["x"]][["value"]], .llVector[["y"]][["value"]], 
#&gt;             .uuVector[["x"]][["value"]], .uuVector[["y"]][["value"]]), 
#&gt;             ncol = 2, dimnames = list(c("coords.lon", "coords.lat"), 
#&gt;                 c("min", "max")))
#&gt;         .oldAttrs &lt;- attributes(.bb)
#&gt;         attributes(.bb) &lt;- c(.oldAttrs, list(referenceFrame = .referenceFrame))
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML] Parsed bounding box: ", toString(.bb), 
#&gt;                 "\n")
#&gt;     }
#&gt;     else {
#&gt;         .bb &lt;- matrix()
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML] No boundedBy element found, bbox is ", 
#&gt;                 .bb, "\n")
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Parsing coordinates from", .smlXPathPosition, 
#&gt;             "\n")
#&gt;     .xmlPosition &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathPosition, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.xmlPosition)) {
#&gt;         .position &lt;- parseSwePosition(.xmlPosition, sos = sos, 
#&gt;             verbose = verbose)
#&gt;         .referenceFrame = attributes(.position)[["referenceFrame"]]
#&gt;         .uom &lt;- lapply(.position, "[[", "uomCode")
#&gt;         names(.uom) &lt;- lapply(.position, "[[", "axisID")
#&gt;         .name &lt;- lapply(.position, "[[", "name")
#&gt;         names(.name) &lt;- lapply(.position, "[[", "axisID")
#&gt;         .values &lt;- lapply(.position, "[[", "value")
#&gt;         names(.values) &lt;- lapply(.position, "[[", "axisID")
#&gt;         if (any(is.na(names(.values)))) {
#&gt;             warning("[parseSensorML] No axisID given, cannot name data.frame with them, trying 'name'.")
#&gt;             names(.values) &lt;- lapply(.position, "[[", "name")
#&gt;         }
#&gt;         if (verbose) {
#&gt;             cat("[parseSensorML] names: ", names(.values), "\n")
#&gt;             cat("[parseSensorML] values: ", toString(.values), 
#&gt;                 "\n")
#&gt;         }
#&gt;         .coords &lt;- data.frame(.values)
#&gt;         .oldAttrs &lt;- attributes(.coords)
#&gt;         attributes(.coords) &lt;- c(as.list(.oldAttrs), list(referenceFrame = .referenceFrame, 
#&gt;             uom = .uom, name = .name))
#&gt;         if (!is.na(.id)) 
#&gt;             row.names(.coords) &lt;- .id
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML]  row names: ", row.names(.coords), 
#&gt;                 "\n")
#&gt;     }
#&gt;     else {
#&gt;         .coords &lt;- data.frame()
#&gt;     }
#&gt;     .sml = SensorML(xml = obj, coords = .coords, id = .id, name = .shortName, 
#&gt;         description = .description, boundedBy = .bb)
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML]  Done: ", toString(.sml), "\n")
#&gt;     return(.sml)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservation
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (sos@verboseOutput) {
#&gt;         cat("[parseGetObservationResponse] entering... \n")
#&gt;         print(obj)
#&gt;     }
#&gt;     .observationsXML &lt;- xml2::xml_find_all(x = obj, xpath = "sos20:observationData", 
#&gt;         ns = SosAllNamespaces(version = sos200_version))
#&gt;     featureCache &lt;&lt;- list()
#&gt;     .observations &lt;- sapply(.observationsXML, parseObservation_2.0, 
#&gt;         sos = sos)
#&gt;     featureCache &lt;&lt;- list()
#&gt;     return(.observations)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetFeatureOfInterestResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (sos@verboseOutput) {
#&gt;         cat("[parseGetFeatureOfInterestResponse] entering... \n")
#&gt;         print(obj)
#&gt;     }
#&gt;     .featureXML &lt;- xml2::xml_find_all(x = obj, xpath = "sos20:featureMember", 
#&gt;         SosAllNamespaces(version = sos200_version))
#&gt;     .foi = sapply(.featureXML, .parseFeatureMember, sos = sos)
#&gt;     return(.foi)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function (obj, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseOwsExceptionReport] Starting ...\n")
#&gt;     .docRoot &lt;- xml2::xml_root(x = obj)
#&gt;     .version &lt;- xml2::xml_attr(x = .docRoot, attr = "version")
#&gt;     .lang &lt;- xml2::xml_attr(x = .docRoot, attr = "lang", default = NA_character_)
#&gt;     .exceptionsXML &lt;- xml2::xml_find_all(x = .docRoot, xpath = paste0("//", 
#&gt;         owsExceptionName), ns = SosAllNamespaces())
#&gt;     .exceptions = sapply(.exceptionsXML, parseOwsException)
#&gt;     if (verbose) 
#&gt;         cat("[parseOwsExceptionReport]", length(.exceptions), 
#&gt;             "exceptions.")
#&gt;     .report &lt;- OwsExceptionReport(version = .version, lang = .lang, 
#&gt;         exceptions = .exceptions)
#&gt;     return(.report)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetDataAvailabilityResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse]")
#&gt;     if (sos@version != sos200_version) {
#&gt;         stop(paste0("[parseGetDataAvailabilityResponse] SOS version 2.0 required! Received '", 
#&gt;             sos@version, "'"))
#&gt;     }
#&gt;     .gdaMembers &lt;- xml2::xml_find_all(x = obj, xpath = sosGDAMemberName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse] with", length(.gdaMembers), 
#&gt;             "element(s).\n")
#&gt;     .phenTimeCache &lt;&lt;- list()
#&gt;     .parsedGDAMembers &lt;- lapply(.gdaMembers, .parseGDAMember, 
#&gt;         sos, verbose)
#&gt;     .phenTimeCache &lt;&lt;- list()
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse] Done. Processed", 
#&gt;             length(.parsedGDAMembers), "elements")
#&gt;     return(.parsedGDAMembers)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Measurement`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseMeasurement]\n")
#&gt;     .samplingTimeXml &lt;- xml2::xml_child(x = obj, search = omSamplingTimeName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .samplingTime &lt;- parseTime(obj = .samplingTimeXml, format = sosTimeFormat(sos), 
#&gt;         verbose = verbose)
#&gt;     .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omProcedureName, ns = SosAllNamespaces()), attr = "href")
#&gt;     .observedProperty &lt;- SwePhenomenonProperty(href = xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omObservedPropertyName, ns = SosAllNamespaces()), 
#&gt;         attr = "href"))
#&gt;     .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, 
#&gt;         ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;     .result &lt;- parseMeasure(xml2::xml_child(x = obj, search = omResultName, 
#&gt;         ns = SosAllNamespaces()))
#&gt;     .measurement &lt;- OmMeasurement(samplingTime = .samplingTime, 
#&gt;         procedure = .procedure, observedProperty = .observedProperty, 
#&gt;         featureOfInterest = .featureOfInterest, result = .result)
#&gt;     return(.measurement)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:member`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (xml2::xml_length(x = obj) &gt;= 1) {
#&gt;         .child &lt;- xml2::xml_child(obj)
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationProperty] Parsing child of member:", 
#&gt;                 xml2::xml_name(x = .child, ns = SosAllNamespaces()), 
#&gt;                 "\n")
#&gt;         .mResult &lt;- parseOM(.child, sos, verbose)
#&gt;     }
#&gt;     else {
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationProperty] Member has no direct child!\n")
#&gt;         .href &lt;- xml2::xml_attr(x = obj, attr = "href", default = NA_character_)
#&gt;         if (!is.na(.href)) {
#&gt;             warning(paste("[parseObservationProperty] Only reference to Observation was returned:", 
#&gt;                 .href))
#&gt;             .mResult &lt;- OmObservationProperty(href = .href)
#&gt;         }
#&gt;         else {
#&gt;             warning("[parseObservationProperty] No observation found!")
#&gt;             .mResult &lt;- OmObservationProperty()
#&gt;         }
#&gt;     }
#&gt;     return(.mResult)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Observation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .id &lt;- xml2::xml_attr(x = obj, attr = "id", default = NA_character_)
#&gt;     if (verbose) 
#&gt;         cat("[parseObservation]", .id, "\n")
#&gt;     .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omProcedureName, ns = SosAllNamespaces()), attr = "href", 
#&gt;         default = NA_character_)
#&gt;     .observedProperty &lt;- parsePhenomenonProperty(xml2::xml_child(x = obj, 
#&gt;         search = omObservedPropertyName, ns = SosAllNamespaces()), 
#&gt;         verbose = verbose)
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omSamplingTimeName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .samplingTime &lt;- parseTime(obj = xml2::xml_child(x = obj, 
#&gt;             search = omSamplingTimeName, ns = SosAllNamespaces()), 
#&gt;             format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         warning("om:samplingTime is mandatory in om:Observation, but is missing!")
#&gt;         .samplingTime &lt;- NULL
#&gt;     }
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omFeatureOfInterestName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, 
#&gt;             search = omFeatureOfInterestName, ns = SosAllNamespaces()), 
#&gt;             sos = sos, verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         warning("om:featureOfInterest is mandatory in om:Observation, but is missing!")
#&gt;         .featureOfInterest &lt;- NULL
#&gt;     }
#&gt;     .resultParsingFunction &lt;- sosParsers(sos)[[omResultName]]
#&gt;     .result &lt;- .resultParsingFunction(xml2::xml_child(x = obj, 
#&gt;         search = omResultName, ns = SosAllNamespaces()), sos, 
#&gt;         verbose)
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omResultTimeName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .resultTime &lt;- parseTime(obj = xml2::xml_child(x = obj, 
#&gt;             search = omResultTimeName, ns = SosAllNamespaces()), 
#&gt;             format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         .resultTime &lt;- NULL
#&gt;     }
#&gt;     .obs &lt;- OmObservation(samplingTime = .samplingTime, procedure = .procedure, 
#&gt;         observedProperty = .observedProperty, featureOfInterest = .featureOfInterest, 
#&gt;         result = .result)
#&gt;     return(.obs)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ObservationCollection`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .members &lt;- xml2::xml_find_all(x = obj, xpath = omMemberName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseObservationCollection] with ", length(.members), 
#&gt;             "element(s).\n")
#&gt;     .env &lt;- xml2::xml_child(x = obj, search = paste0(gmlBoundedByName, 
#&gt;         "/", gmlEnvelopeName))
#&gt;     if (!is.na(.env)) {
#&gt;         .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, 
#&gt;             attr = "srsName", ns = SosAllNamespaces()), lowerCorner = xml2::xml_text(x = xml2::xml_child(x = .env, 
#&gt;             search = gmlLowerCornerName, ns = SosAllNamespaces())), 
#&gt;             upperCorner = xml2::xml_text(x = xml2::xml_child(x = .env, 
#&gt;                 search = gmlUpperCornerName, ns = SosAllNamespaces())))
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationCollection] Parsed envelope:", 
#&gt;                 toString(.boundedBy), "\n")
#&gt;         if (sosSwitchCoordinates(sos)) {
#&gt;             warning("Switching coordinates in envelope of ObservationCollection!")
#&gt;             .origLC &lt;- strsplit(x = .boundedBy[["lowerCorner"]], 
#&gt;                 split = " ")
#&gt;             .lC &lt;- paste(.origLC[[1]][[2]], .origLC[[1]][[1]])
#&gt;             .origUC &lt;- strsplit(x = .boundedBy[["upperCorner"]], 
#&gt;                 split = " ")
#&gt;             .uC &lt;- paste(.origUC[[1]][[2]], .origUC[[1]][[1]])
#&gt;             .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, 
#&gt;                 attr = "srsName"), lowerCorner = .lC, upperCorner = .uC)
#&gt;         }
#&gt;     }
#&gt;     else {
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationCollection] Empty envelope!\n")
#&gt;         .boundedBy &lt;- list()
#&gt;     }
#&gt;     .resultList &lt;- lapply(X = .members, FUN = parseOM, sos = sos, 
#&gt;         verbose = verbose)
#&gt;     names(.resultList) &lt;- lapply(X = .resultList, FUN = class)
#&gt;     if (is.list(.resultList)) {
#&gt;         .obsColl &lt;- OmObservationCollection(members = .resultList, 
#&gt;             boundedBy = .boundedBy)
#&gt;     }
#&gt;     else {
#&gt;         .obsColl &lt;- OmObservationCollection(members = list(.resultList), 
#&gt;             boundedBy = .boundedBy)
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseObservationCollection] Done. Processed", length(.obsColl), 
#&gt;             "elements:", names(sosResult(.obsColl)), "\n")
#&gt;     return(.obsColl)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:result`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) {
#&gt;         cat("[parseResult] Starting ...\n")
#&gt;     }
#&gt;     .result &lt;- NULL
#&gt;     .children &lt;- xml2::xml_children(x = obj)
#&gt;     if (verbose) 
#&gt;         cat("[parseResult]", length(.children), " non-text nodes, names:", 
#&gt;             names(.children), "\n")
#&gt;     if (length(.children) == 0) {
#&gt;         .children &lt;- xml2::xml_children(x = obj)
#&gt;         stop("Continue implementation here: OM-methods-parsing.R")
#&gt;         cat("[parseResult] No non-text nodes in result, returning NULL.\n")
#&gt;         .typeAttributValue &lt;- xml2::xml_attr(x = obj, attr = om20ResultTypeAttributeName, 
#&gt;             default = NA_character_)
#&gt;         .typeWithQualifiedname &lt;- strsplit(.typeAttributValue, 
#&gt;             ":")
#&gt;         .type &lt;- NA_character_
#&gt;         if (length(.typeWithQualifiedname) &gt; 0) {
#&gt;             if (length(.typeWithQualifiedname[[1]]) &gt; 1) {
#&gt;                 .type &lt;- .typeWithQualifiedname[[1]][2]
#&gt;             }
#&gt;         }
#&gt;         if (!is.na(.type)) {
#&gt;             if (.type == om20ResultMeasureTypeName) {
#&gt;                 return(xml2::xml_text(x = obj))
#&gt;             }
#&gt;         }
#&gt;         return(NULL)
#&gt;     }
#&gt;     .name &lt;- xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces())
#&gt;     if (.name == sweDataArrayName) {
#&gt;         if (verbose) 
#&gt;             cat("[parseResult] Parsing result with swe:DataArray.\n")
#&gt;         .dataArrayParsingFunction &lt;- sosParsers(sos)[[sweDataArrayName]]
#&gt;         .result &lt;- .dataArrayParsingFunction(.children[[1]], 
#&gt;             sos, verbose)
#&gt;     }
#&gt;     else if (.name == xmlTextNodeName) {
#&gt;         .result &lt;- as.numeric(xml2::xml_text(x = .children))
#&gt;         if (is.na(.result)) {
#&gt;             .result &lt;- xml2::xml_text(x = .children, trim = TRUE)
#&gt;         }
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseResult] Parsing of given result is NOT supported:", 
#&gt;             xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces()), 
#&gt;             "-- only", sweDataArrayName, " or text nodes containing strings or numbers can be parsed."))
#&gt;     }
#&gt;     if (is.null(.result)) {
#&gt;         stop("[parseResult] result is null! Given result:\n")
#&gt;         print(obj)
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseResult] ... done.\n")
#&gt;     return(.result)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:DataArray`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .elementCount &lt;- xml2::xml_text(xml2::xml_find_first(x = obj, 
#&gt;         xpath = "./swe:elementCount/swe:Count/swe:value", ns = SosAllNamespaces()))
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray] Parsing DataArray with", .elementCount, 
#&gt;             "elements.\n")
#&gt;     .elementTypeParser &lt;- sosParsers(sos)[[sweElementTypeName]]
#&gt;     .fields &lt;- .elementTypeParser(obj = xml2::xml_child(x = obj, 
#&gt;         search = sweElementTypeName, ns = SosAllNamespaces()), 
#&gt;         verbose = verbose)
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray]  Parsed field descriptions:", toString(.fields), 
#&gt;             "\n")
#&gt;     .encParser &lt;- sosParsers(sos)[[sweEncodingName]]
#&gt;     .encoding &lt;- .encParser(obj = xml2::xml_child(x = obj, search = sweEncodingName, 
#&gt;         ns = SosAllNamespaces()), verbose = verbose)
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray]  Parsed encoding description:", 
#&gt;             toString(.encoding), "\n")
#&gt;     .valParser &lt;- sosParsers(sos)[[sweValuesName]]
#&gt;     .values &lt;- .valParser(values = xml2::xml_child(x = obj, search = sweValuesName, 
#&gt;         ns = SosAllNamespaces()), fields = .fields, encoding = .encoding, 
#&gt;         sos = sos, verbose = verbose)
#&gt;     return(.values)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:elementType`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .simpleDataRecord &lt;- xml2::xml_child(x = obj, search = sweSimpleDataRecordName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .dataRecord &lt;- xml2::xml_child(x = obj, search = sweDataRecordName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.simpleDataRecord) || !is.na(.dataRecord)) {
#&gt;         if (!is.na(.simpleDataRecord)) 
#&gt;             .dr &lt;- .simpleDataRecord
#&gt;         else .dr &lt;- .dataRecord
#&gt;         .fields &lt;- xml2::xml_find_all(x = .dr, xpath = sweFieldName, 
#&gt;             ns = SosAllNamespaces())
#&gt;         if (verbose) 
#&gt;             cat("[parseElementType] Got data record with", length(.fields), 
#&gt;                 "fields. \n")
#&gt;         .parsedFields &lt;- lapply(.fields, parseField, sos = sos, 
#&gt;             verbose = verbose)
#&gt;         .names &lt;- sapply(.parsedFields, "[", .sosParseFieldName)
#&gt;         names(.parsedFields) &lt;- .names
#&gt;         if (verbose) 
#&gt;             cat("[parseElementType] Names of parsed fields:", 
#&gt;                 names(.fields), "\n")
#&gt;         return(.parsedFields)
#&gt;     }
#&gt;     else {
#&gt;         stop(paste("Cannot parse swe:elementType, only children of type", 
#&gt;             sweSimpleDataRecordName, "and", sweDataRecordName, 
#&gt;             "are supported!"))
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:encoding`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .textBlock &lt;- xml2::xml_child(x = obj, search = sweTextBlockName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .textEncoding &lt;- xml2::xml_child(x = obj, search = sweTextEncodingName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!(is.na(.textBlock))) {
#&gt;         .tb &lt;- parseTextBlock(.textBlock)
#&gt;         return(.tb)
#&gt;     }
#&gt;     else if (!(is.na(.textEncoding))) {
#&gt;         .tb &lt;- parseTextEncoding(.textEncoding)
#&gt;         return(.tb)
#&gt;     }
#&gt;     else {
#&gt;         stop(paste("Cannot parse swe:encoding, only", sweTextBlockName, 
#&gt;             "and", sweTextEncodingName, "are supported!"))
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:values`
#&gt; function (values, fields, encoding, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Parsing swe:values using", toString(encoding), 
#&gt;             "and", length(fields), "fields:", toString(names(fields)), 
#&gt;             "\n")
#&gt;     if (!(inherits(encoding, "SweTextBlock") || inherits(encoding, 
#&gt;         "SweTextEncoding"))) {
#&gt;         stop("Handling for given encoding not implemented!")
#&gt;     }
#&gt;     .converters &lt;- sosDataFieldConverters(sos)
#&gt;     .blockLines &lt;- strsplit(x = xml2::xml_text(x = values), split = encoding@blockSeparator)
#&gt;     .tokenLines &lt;- sapply(.blockLines, strsplit, split = encoding@tokenSeparator)
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Parsing values from lines: ", toString(.tokenLines), 
#&gt;             "\n")
#&gt;     .tempId = "tempID"
#&gt;     .data &lt;- data.frame(seq(1, length(.tokenLines)))
#&gt;     names(.data) &lt;- .tempId
#&gt;     .fieldCount &lt;- length(fields)
#&gt;     for (.currentFieldIdx in seq(1, .fieldCount)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Processing field index", .currentFieldIdx, 
#&gt;                 "of", .fieldCount, "\n")
#&gt;         .currentValues &lt;- sapply(.tokenLines, "[[", .currentFieldIdx)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Current values: ", toString(.currentValues), 
#&gt;                 "\n")
#&gt;         .currentField &lt;- fields[[.currentFieldIdx]]
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Parsing field", paste(.currentField), 
#&gt;                 "\n")
#&gt;         .fieldDefinition &lt;- .currentField[[.sosParseFieldDefinition]]
#&gt;         .method &lt;- .converters[[.fieldDefinition]]
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] Using converter:\n")
#&gt;             print(.method)
#&gt;         }
#&gt;         if (is.null(.method)) {
#&gt;             if (!is.na(.currentField[.sosParseFieldUOM])) {
#&gt;                 .method &lt;- .converters[[.currentField[[.sosParseFieldUOM]]]]
#&gt;                 if (is.null(.method)) {
#&gt;                   warning(paste("No converter for the unit of measurement ", 
#&gt;                     .currentField[[.sosParseFieldUOM]], " with the definition ", 
#&gt;                     .currentField[[.sosParseFieldDefinition]], 
#&gt;                     "! Trying a default, but you can add one when creating a SOS using", 
#&gt;                     "SosDataFieldConvertingFunctions().\n"))
#&gt;                   .method &lt;- .converters[["fallBack"]]
#&gt;                 }
#&gt;             }
#&gt;             else {
#&gt;                 warning(paste("No converter found for the given field", 
#&gt;                   toString(.currentField)))
#&gt;             }
#&gt;         }
#&gt;         if (is.null(.method)) {
#&gt;             warning(paste("No converter found! Using field as is:", 
#&gt;                 as.character(fields[[.currentFieldIdx]]), "\n"))
#&gt;         }
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] Using converter function:\n")
#&gt;             show(.method)
#&gt;         }
#&gt;         .currentValues &lt;- .method(x = .currentValues, sos = sos)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Binding additional data.frame for", 
#&gt;                 .currentField[[.sosParseFieldName]], "-- value range", 
#&gt;                 toString(range(.currentValues)), "\n")
#&gt;         .newData &lt;- data.frame(.currentValues)
#&gt;         .newDataName &lt;- .currentField[[.sosParseFieldName]]
#&gt;         names(.newData) &lt;- .cleanupColumnName(.newDataName)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Added column name:", names(.newData), 
#&gt;                 "\n")
#&gt;         .data &lt;- cbind(.data, .newData)
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] The new bound data frame:\n")
#&gt;             str(.data)
#&gt;         }
#&gt;         .addAttrs &lt;- as.list(.currentField)
#&gt;         names(.addAttrs) &lt;- .sosParseFieldReadable[names(.currentField)]
#&gt;         .lastColumn &lt;- dim(.data)[[2]]
#&gt;         .oldAttrs &lt;- attributes(.data[, .lastColumn])
#&gt;         attributes(.data[, .lastColumn]) &lt;- c(as.list(.oldAttrs), 
#&gt;             .addAttrs)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Added attributes to new data:", 
#&gt;                 toString(.addAttrs), "[ names: ", toString(names(.addAttrs)), 
#&gt;                 "]", "\n[parseValues] Old attributes list is", 
#&gt;                 toString(.oldAttrs), "\n[parseValues] New attributes list is", 
#&gt;                 toString(attributes(.data[, .lastColumn])), "\n")
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Removing temporary first column\n")
#&gt;     .data &lt;- .data[, !colnames(.data) %in% .tempId]
#&gt;     if (verbose) {
#&gt;         cat("[parseValues] returning final data frame:\n")
#&gt;         str(.data)
#&gt;     }
#&gt;     return(.data)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Position`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .rF &lt;- xml2::xml_attr(x = obj, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseSwePosition] with referenceFrame", .rF, "\n")
#&gt;     .location &lt;- xml2::xml_child(x = obj, search = sweLocationName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .parser &lt;- sosParsers(sos)[[sweLocationName]]
#&gt;     .pos &lt;- .parser(.location, sos = sos, verbose = verbose)
#&gt;     .oldAttrs &lt;- attributes(.pos)
#&gt;     attributes(.pos) &lt;- c(.oldAttrs, list(referenceFrame = .rF))
#&gt;     return(.pos)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:location`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .vector &lt;- xml2::xml_child(x = obj, search = sweVectorName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .id &lt;- xml2::xml_attr(x = obj, attr = "id")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweLocation] with id", .id, "\n")
#&gt;     .parser &lt;- sosParsers(sos)[[sweVectorName]]
#&gt;     location &lt;- .parser(.vector, sos = sos, verbose = verbose)
#&gt;     return(location)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Vector`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .children &lt;- xml2::xml_find_all(x = obj, xpath = sweCoordinateName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .parser &lt;- sosParsers(sos)[[sweCoordinateName]]
#&gt;     .vector &lt;- lapply(X = .children, FUN = .parser, sos = sos, 
#&gt;         verbose = verbose)
#&gt;     names(.vector) &lt;- sapply(.vector, function(current) {
#&gt;         return(current$axisID)
#&gt;     })
#&gt;     if (verbose) 
#&gt;         cat("[parseSweVector] parsed vector with coordinates: ", 
#&gt;             toString(names(.vector)), "\n")
#&gt;     return(.vector)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:coordinate`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .name &lt;- xml2::xml_attr(x = obj, attr = "name")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] with name", .name, "\n")
#&gt;     .quantity &lt;- xml2::xml_child(x = obj, search = sweQuantityName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .axisID &lt;- xml2::xml_attr(x = .quantity, attr = "axisID")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] axisID: ", .axisID, "\n")
#&gt;     .uomNode &lt;- xml2::xml_child(x = .quantity, search = sweUomName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .uomCode &lt;- xml2::xml_attr(x = .uomNode, attr = "code", ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] uomCode: ", .uomCode, "\n")
#&gt;     .valueNode &lt;- xml2::xml_child(x = .quantity, search = sweValueName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .value &lt;- as.double(xml2::xml_text(x = .valueNode))
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] value: ", .value, "\n")
#&gt;     return(list(name = .name, axisID = .axisID, uomCode = .uomCode, 
#&gt;         value = .value))
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:GeometryObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:GeometryObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CategoryObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:CategoryObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CountObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:CountObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TruthObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:TruthObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TemporalObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:TemporalObservatio is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ComplexObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:ComplexObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/csv`
#&gt; function (obj, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Processing CSV...\n")
#&gt;     .lines &lt;- strsplit(x = obj, split = "\n")[[1]]
#&gt;     .data &lt;- do.call(what = "strsplit", args = list(.lines, split = ","))
#&gt;     .names &lt;- .data[[1]]
#&gt;     .newNames &lt;- c()
#&gt;     for (.n in .names) {
#&gt;         .newNames &lt;- c(.newNames, gsub(pattern = "\"", replacement = "", 
#&gt;             x = .n))
#&gt;     }
#&gt;     .names &lt;- .newNames
#&gt;     .rows &lt;- length(.data)
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Got", .rows, "lines of data.\n")
#&gt;     if (.rows == 1) {
#&gt;         warnings(paste("Received just one line of data: ", .data, 
#&gt;             "\n"))
#&gt;         return(.data[[1]])
#&gt;     }
#&gt;     .df &lt;- NULL
#&gt;     for (.r in seq(2, .rows)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseCSV] Processing row in CSV:", .data[[.r]], 
#&gt;                 "\n")
#&gt;         .row.df &lt;- as.data.frame(.data[[.r]][1])
#&gt;         names(.row.df) &lt;- .names[[1]]
#&gt;         for (i in seq(2, length(.names))) {
#&gt;             .df &lt;- as.data.frame(.data[[.r]][i])
#&gt;             names(.df) &lt;- .names[[i]]
#&gt;             .row.df &lt;- cbind(.row.df, .df)
#&gt;         }
#&gt;         if (is.null(.df)) 
#&gt;             .df &lt;- .row.df
#&gt;         else .df &lt;- do.call(rbind, list(.df, .row.df))
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Done.\n")
#&gt;     return(.df)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml;subtype="om/1.0.0"`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`application/vnd.google-earth.kml+xml`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseKML] Processing KML... returning raw object!\n")
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $kml
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseKML] Processing KML... returning raw object!\n")
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
<span class='co'># use inclusion and exclusion, important: even the just added function needs to</span>
<span class='co'># be included manually!</span>
<span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>,
        <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>, <span class='st'>"ExceptionReport"</span>))</div><div class='output co'>#&gt; $GetObservation
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Starting... \n")
#&gt;     .id &lt;- .smlIdentifier(obj, "uniqueID", verbose = verbose)
#&gt;     .shortName &lt;- .smlIdentifier(obj, "shortName", verbose = verbose)
#&gt;     .descrNode &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathDescription, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .description &lt;- xml2::xml_text(x = .descrNode)
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Got ID", .id, "and shortName", .shortName, 
#&gt;             "and description", .description, "\n")
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Parsing boundedBy from", .smlXPathObservedBBox, 
#&gt;             "\n")
#&gt;     .observedBBox &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathObservedBBox, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.observedBBox)) {
#&gt;         .referenceFrame &lt;- xml2::xml_attr(x = .observedBBox, 
#&gt;             attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;         .llVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox, 
#&gt;             search = paste0(sweUpperCornerName, "/", sweVectorName), 
#&gt;             ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;         .uuVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox, 
#&gt;             search = paste0(sweLowerCornerName, "/", sweVectorName), 
#&gt;             ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;         .bb &lt;- matrix(c(.llVector[["x"]][["value"]], .llVector[["y"]][["value"]], 
#&gt;             .uuVector[["x"]][["value"]], .uuVector[["y"]][["value"]]), 
#&gt;             ncol = 2, dimnames = list(c("coords.lon", "coords.lat"), 
#&gt;                 c("min", "max")))
#&gt;         .oldAttrs &lt;- attributes(.bb)
#&gt;         attributes(.bb) &lt;- c(.oldAttrs, list(referenceFrame = .referenceFrame))
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML] Parsed bounding box: ", toString(.bb), 
#&gt;                 "\n")
#&gt;     }
#&gt;     else {
#&gt;         .bb &lt;- matrix()
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML] No boundedBy element found, bbox is ", 
#&gt;                 .bb, "\n")
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML] Parsing coordinates from", .smlXPathPosition, 
#&gt;             "\n")
#&gt;     .xmlPosition &lt;- xml2::xml_find_first(x = obj, xpath = .smlXPathPosition, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.xmlPosition)) {
#&gt;         .position &lt;- parseSwePosition(.xmlPosition, sos = sos, 
#&gt;             verbose = verbose)
#&gt;         .referenceFrame = attributes(.position)[["referenceFrame"]]
#&gt;         .uom &lt;- lapply(.position, "[[", "uomCode")
#&gt;         names(.uom) &lt;- lapply(.position, "[[", "axisID")
#&gt;         .name &lt;- lapply(.position, "[[", "name")
#&gt;         names(.name) &lt;- lapply(.position, "[[", "axisID")
#&gt;         .values &lt;- lapply(.position, "[[", "value")
#&gt;         names(.values) &lt;- lapply(.position, "[[", "axisID")
#&gt;         if (any(is.na(names(.values)))) {
#&gt;             warning("[parseSensorML] No axisID given, cannot name data.frame with them, trying 'name'.")
#&gt;             names(.values) &lt;- lapply(.position, "[[", "name")
#&gt;         }
#&gt;         if (verbose) {
#&gt;             cat("[parseSensorML] names: ", names(.values), "\n")
#&gt;             cat("[parseSensorML] values: ", toString(.values), 
#&gt;                 "\n")
#&gt;         }
#&gt;         .coords &lt;- data.frame(.values)
#&gt;         .oldAttrs &lt;- attributes(.coords)
#&gt;         attributes(.coords) &lt;- c(as.list(.oldAttrs), list(referenceFrame = .referenceFrame, 
#&gt;             uom = .uom, name = .name))
#&gt;         if (!is.na(.id)) 
#&gt;             row.names(.coords) &lt;- .id
#&gt;         if (verbose) 
#&gt;             cat("[parseSensorML]  row names: ", row.names(.coords), 
#&gt;                 "\n")
#&gt;     }
#&gt;     else {
#&gt;         .coords &lt;- data.frame()
#&gt;     }
#&gt;     .sml = SensorML(xml = obj, coords = .coords, id = .id, name = .shortName, 
#&gt;         description = .description, boundedBy = .bb)
#&gt;     if (verbose) 
#&gt;         cat("[parseSensorML]  Done: ", toString(.sml), "\n")
#&gt;     return(.sml)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $ExceptionReport
#&gt; function (xml) 
#&gt; {
#&gt;     return("EXCEPTION!!!11")
#&gt; }
#&gt; &lt;environment: 0xcffa6a8&gt;
#&gt; </div><div class='input'><span class='fu'>SosParsingFunctions</span>(<span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>))</div><div class='output co'>#&gt; $GetCapabilities
#&gt; function (obj, sos) 
#&gt; {
#&gt;     if (sos@version == sos100_version) {
#&gt;         .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;     }
#&gt;     else if (sos@version == sos200_version) {
#&gt;         .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (sos@verboseOutput) {
#&gt;         cat("[parseGetObservationResponse] entering... \n")
#&gt;         print(obj)
#&gt;     }
#&gt;     .observationsXML &lt;- xml2::xml_find_all(x = obj, xpath = "sos20:observationData", 
#&gt;         ns = SosAllNamespaces(version = sos200_version))
#&gt;     featureCache &lt;&lt;- list()
#&gt;     .observations &lt;- sapply(.observationsXML, parseObservation_2.0, 
#&gt;         sos = sos)
#&gt;     featureCache &lt;&lt;- list()
#&gt;     return(.observations)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetFeatureOfInterestResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (sos@verboseOutput) {
#&gt;         cat("[parseGetFeatureOfInterestResponse] entering... \n")
#&gt;         print(obj)
#&gt;     }
#&gt;     .featureXML &lt;- xml2::xml_find_all(x = obj, xpath = "sos20:featureMember", 
#&gt;         SosAllNamespaces(version = sos200_version))
#&gt;     .foi = sapply(.featureXML, .parseFeatureMember, sos = sos)
#&gt;     return(.foi)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function (obj, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseOwsExceptionReport] Starting ...\n")
#&gt;     .docRoot &lt;- xml2::xml_root(x = obj)
#&gt;     .version &lt;- xml2::xml_attr(x = .docRoot, attr = "version")
#&gt;     .lang &lt;- xml2::xml_attr(x = .docRoot, attr = "lang", default = NA_character_)
#&gt;     .exceptionsXML &lt;- xml2::xml_find_all(x = .docRoot, xpath = paste0("//", 
#&gt;         owsExceptionName), ns = SosAllNamespaces())
#&gt;     .exceptions = sapply(.exceptionsXML, parseOwsException)
#&gt;     if (verbose) 
#&gt;         cat("[parseOwsExceptionReport]", length(.exceptions), 
#&gt;             "exceptions.")
#&gt;     .report &lt;- OwsExceptionReport(version = .version, lang = .lang, 
#&gt;         exceptions = .exceptions)
#&gt;     return(.report)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetDataAvailabilityResponse
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse]")
#&gt;     if (sos@version != sos200_version) {
#&gt;         stop(paste0("[parseGetDataAvailabilityResponse] SOS version 2.0 required! Received '", 
#&gt;             sos@version, "'"))
#&gt;     }
#&gt;     .gdaMembers &lt;- xml2::xml_find_all(x = obj, xpath = sosGDAMemberName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse] with", length(.gdaMembers), 
#&gt;             "element(s).\n")
#&gt;     .phenTimeCache &lt;&lt;- list()
#&gt;     .parsedGDAMembers &lt;- lapply(.gdaMembers, .parseGDAMember, 
#&gt;         sos, verbose)
#&gt;     .phenTimeCache &lt;&lt;- list()
#&gt;     if (verbose) 
#&gt;         cat("[parseGetDataAvailabilityResponse] Done. Processed", 
#&gt;             length(.parsedGDAMembers), "elements")
#&gt;     return(.parsedGDAMembers)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Measurement`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseMeasurement]\n")
#&gt;     .samplingTimeXml &lt;- xml2::xml_child(x = obj, search = omSamplingTimeName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .samplingTime &lt;- parseTime(obj = .samplingTimeXml, format = sosTimeFormat(sos), 
#&gt;         verbose = verbose)
#&gt;     .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omProcedureName, ns = SosAllNamespaces()), attr = "href")
#&gt;     .observedProperty &lt;- SwePhenomenonProperty(href = xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omObservedPropertyName, ns = SosAllNamespaces()), 
#&gt;         attr = "href"))
#&gt;     .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, 
#&gt;         ns = SosAllNamespaces()), sos = sos, verbose = verbose)
#&gt;     .result &lt;- parseMeasure(xml2::xml_child(x = obj, search = omResultName, 
#&gt;         ns = SosAllNamespaces()))
#&gt;     .measurement &lt;- OmMeasurement(samplingTime = .samplingTime, 
#&gt;         procedure = .procedure, observedProperty = .observedProperty, 
#&gt;         featureOfInterest = .featureOfInterest, result = .result)
#&gt;     return(.measurement)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:member`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (xml2::xml_length(x = obj) &gt;= 1) {
#&gt;         .child &lt;- xml2::xml_child(obj)
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationProperty] Parsing child of member:", 
#&gt;                 xml2::xml_name(x = .child, ns = SosAllNamespaces()), 
#&gt;                 "\n")
#&gt;         .mResult &lt;- parseOM(.child, sos, verbose)
#&gt;     }
#&gt;     else {
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationProperty] Member has no direct child!\n")
#&gt;         .href &lt;- xml2::xml_attr(x = obj, attr = "href", default = NA_character_)
#&gt;         if (!is.na(.href)) {
#&gt;             warning(paste("[parseObservationProperty] Only reference to Observation was returned:", 
#&gt;                 .href))
#&gt;             .mResult &lt;- OmObservationProperty(href = .href)
#&gt;         }
#&gt;         else {
#&gt;             warning("[parseObservationProperty] No observation found!")
#&gt;             .mResult &lt;- OmObservationProperty()
#&gt;         }
#&gt;     }
#&gt;     return(.mResult)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Observation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .id &lt;- xml2::xml_attr(x = obj, attr = "id", default = NA_character_)
#&gt;     if (verbose) 
#&gt;         cat("[parseObservation]", .id, "\n")
#&gt;     .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, 
#&gt;         search = omProcedureName, ns = SosAllNamespaces()), attr = "href", 
#&gt;         default = NA_character_)
#&gt;     .observedProperty &lt;- parsePhenomenonProperty(xml2::xml_child(x = obj, 
#&gt;         search = omObservedPropertyName, ns = SosAllNamespaces()), 
#&gt;         verbose = verbose)
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omSamplingTimeName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .samplingTime &lt;- parseTime(obj = xml2::xml_child(x = obj, 
#&gt;             search = omSamplingTimeName, ns = SosAllNamespaces()), 
#&gt;             format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         warning("om:samplingTime is mandatory in om:Observation, but is missing!")
#&gt;         .samplingTime &lt;- NULL
#&gt;     }
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omFeatureOfInterestName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, 
#&gt;             search = omFeatureOfInterestName, ns = SosAllNamespaces()), 
#&gt;             sos = sos, verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         warning("om:featureOfInterest is mandatory in om:Observation, but is missing!")
#&gt;         .featureOfInterest &lt;- NULL
#&gt;     }
#&gt;     .resultParsingFunction &lt;- sosParsers(sos)[[omResultName]]
#&gt;     .result &lt;- .resultParsingFunction(xml2::xml_child(x = obj, 
#&gt;         search = omResultName, ns = SosAllNamespaces()), sos, 
#&gt;         verbose)
#&gt;     if (!is.na(xml2::xml_child(x = obj, search = omResultTimeName, 
#&gt;         ns = SosAllNamespaces()))) {
#&gt;         .resultTime &lt;- parseTime(obj = xml2::xml_child(x = obj, 
#&gt;             search = omResultTimeName, ns = SosAllNamespaces()), 
#&gt;             format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;     }
#&gt;     else {
#&gt;         .resultTime &lt;- NULL
#&gt;     }
#&gt;     .obs &lt;- OmObservation(samplingTime = .samplingTime, procedure = .procedure, 
#&gt;         observedProperty = .observedProperty, featureOfInterest = .featureOfInterest, 
#&gt;         result = .result)
#&gt;     return(.obs)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ObservationCollection`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .members &lt;- xml2::xml_find_all(x = obj, xpath = omMemberName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseObservationCollection] with ", length(.members), 
#&gt;             "element(s).\n")
#&gt;     .env &lt;- xml2::xml_child(x = obj, search = paste0(gmlBoundedByName, 
#&gt;         "/", gmlEnvelopeName))
#&gt;     if (!is.na(.env)) {
#&gt;         .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, 
#&gt;             attr = "srsName", ns = SosAllNamespaces()), lowerCorner = xml2::xml_text(x = xml2::xml_child(x = .env, 
#&gt;             search = gmlLowerCornerName, ns = SosAllNamespaces())), 
#&gt;             upperCorner = xml2::xml_text(x = xml2::xml_child(x = .env, 
#&gt;                 search = gmlUpperCornerName, ns = SosAllNamespaces())))
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationCollection] Parsed envelope:", 
#&gt;                 toString(.boundedBy), "\n")
#&gt;         if (sosSwitchCoordinates(sos)) {
#&gt;             warning("Switching coordinates in envelope of ObservationCollection!")
#&gt;             .origLC &lt;- strsplit(x = .boundedBy[["lowerCorner"]], 
#&gt;                 split = " ")
#&gt;             .lC &lt;- paste(.origLC[[1]][[2]], .origLC[[1]][[1]])
#&gt;             .origUC &lt;- strsplit(x = .boundedBy[["upperCorner"]], 
#&gt;                 split = " ")
#&gt;             .uC &lt;- paste(.origUC[[1]][[2]], .origUC[[1]][[1]])
#&gt;             .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, 
#&gt;                 attr = "srsName"), lowerCorner = .lC, upperCorner = .uC)
#&gt;         }
#&gt;     }
#&gt;     else {
#&gt;         if (verbose) 
#&gt;             cat("[parseObservationCollection] Empty envelope!\n")
#&gt;         .boundedBy &lt;- list()
#&gt;     }
#&gt;     .resultList &lt;- lapply(X = .members, FUN = parseOM, sos = sos, 
#&gt;         verbose = verbose)
#&gt;     names(.resultList) &lt;- lapply(X = .resultList, FUN = class)
#&gt;     if (is.list(.resultList)) {
#&gt;         .obsColl &lt;- OmObservationCollection(members = .resultList, 
#&gt;             boundedBy = .boundedBy)
#&gt;     }
#&gt;     else {
#&gt;         .obsColl &lt;- OmObservationCollection(members = list(.resultList), 
#&gt;             boundedBy = .boundedBy)
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseObservationCollection] Done. Processed", length(.obsColl), 
#&gt;             "elements:", names(sosResult(.obsColl)), "\n")
#&gt;     return(.obsColl)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:result`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) {
#&gt;         cat("[parseResult] Starting ...\n")
#&gt;     }
#&gt;     .result &lt;- NULL
#&gt;     .children &lt;- xml2::xml_children(x = obj)
#&gt;     if (verbose) 
#&gt;         cat("[parseResult]", length(.children), " non-text nodes, names:", 
#&gt;             names(.children), "\n")
#&gt;     if (length(.children) == 0) {
#&gt;         .children &lt;- xml2::xml_children(x = obj)
#&gt;         stop("Continue implementation here: OM-methods-parsing.R")
#&gt;         cat("[parseResult] No non-text nodes in result, returning NULL.\n")
#&gt;         .typeAttributValue &lt;- xml2::xml_attr(x = obj, attr = om20ResultTypeAttributeName, 
#&gt;             default = NA_character_)
#&gt;         .typeWithQualifiedname &lt;- strsplit(.typeAttributValue, 
#&gt;             ":")
#&gt;         .type &lt;- NA_character_
#&gt;         if (length(.typeWithQualifiedname) &gt; 0) {
#&gt;             if (length(.typeWithQualifiedname[[1]]) &gt; 1) {
#&gt;                 .type &lt;- .typeWithQualifiedname[[1]][2]
#&gt;             }
#&gt;         }
#&gt;         if (!is.na(.type)) {
#&gt;             if (.type == om20ResultMeasureTypeName) {
#&gt;                 return(xml2::xml_text(x = obj))
#&gt;             }
#&gt;         }
#&gt;         return(NULL)
#&gt;     }
#&gt;     .name &lt;- xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces())
#&gt;     if (.name == sweDataArrayName) {
#&gt;         if (verbose) 
#&gt;             cat("[parseResult] Parsing result with swe:DataArray.\n")
#&gt;         .dataArrayParsingFunction &lt;- sosParsers(sos)[[sweDataArrayName]]
#&gt;         .result &lt;- .dataArrayParsingFunction(.children[[1]], 
#&gt;             sos, verbose)
#&gt;     }
#&gt;     else if (.name == xmlTextNodeName) {
#&gt;         .result &lt;- as.numeric(xml2::xml_text(x = .children))
#&gt;         if (is.na(.result)) {
#&gt;             .result &lt;- xml2::xml_text(x = .children, trim = TRUE)
#&gt;         }
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseResult] Parsing of given result is NOT supported:", 
#&gt;             xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces()), 
#&gt;             "-- only", sweDataArrayName, " or text nodes containing strings or numbers can be parsed."))
#&gt;     }
#&gt;     if (is.null(.result)) {
#&gt;         stop("[parseResult] result is null! Given result:\n")
#&gt;         print(obj)
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseResult] ... done.\n")
#&gt;     return(.result)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:DataArray`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .elementCount &lt;- xml2::xml_text(xml2::xml_find_first(x = obj, 
#&gt;         xpath = "./swe:elementCount/swe:Count/swe:value", ns = SosAllNamespaces()))
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray] Parsing DataArray with", .elementCount, 
#&gt;             "elements.\n")
#&gt;     .elementTypeParser &lt;- sosParsers(sos)[[sweElementTypeName]]
#&gt;     .fields &lt;- .elementTypeParser(obj = xml2::xml_child(x = obj, 
#&gt;         search = sweElementTypeName, ns = SosAllNamespaces()), 
#&gt;         verbose = verbose)
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray]  Parsed field descriptions:", toString(.fields), 
#&gt;             "\n")
#&gt;     .encParser &lt;- sosParsers(sos)[[sweEncodingName]]
#&gt;     .encoding &lt;- .encParser(obj = xml2::xml_child(x = obj, search = sweEncodingName, 
#&gt;         ns = SosAllNamespaces()), verbose = verbose)
#&gt;     if (verbose) 
#&gt;         cat("[parseDataArray]  Parsed encoding description:", 
#&gt;             toString(.encoding), "\n")
#&gt;     .valParser &lt;- sosParsers(sos)[[sweValuesName]]
#&gt;     .values &lt;- .valParser(values = xml2::xml_child(x = obj, search = sweValuesName, 
#&gt;         ns = SosAllNamespaces()), fields = .fields, encoding = .encoding, 
#&gt;         sos = sos, verbose = verbose)
#&gt;     return(.values)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:elementType`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .simpleDataRecord &lt;- xml2::xml_child(x = obj, search = sweSimpleDataRecordName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .dataRecord &lt;- xml2::xml_child(x = obj, search = sweDataRecordName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!is.na(.simpleDataRecord) || !is.na(.dataRecord)) {
#&gt;         if (!is.na(.simpleDataRecord)) 
#&gt;             .dr &lt;- .simpleDataRecord
#&gt;         else .dr &lt;- .dataRecord
#&gt;         .fields &lt;- xml2::xml_find_all(x = .dr, xpath = sweFieldName, 
#&gt;             ns = SosAllNamespaces())
#&gt;         if (verbose) 
#&gt;             cat("[parseElementType] Got data record with", length(.fields), 
#&gt;                 "fields. \n")
#&gt;         .parsedFields &lt;- lapply(.fields, parseField, sos = sos, 
#&gt;             verbose = verbose)
#&gt;         .names &lt;- sapply(.parsedFields, "[", .sosParseFieldName)
#&gt;         names(.parsedFields) &lt;- .names
#&gt;         if (verbose) 
#&gt;             cat("[parseElementType] Names of parsed fields:", 
#&gt;                 names(.fields), "\n")
#&gt;         return(.parsedFields)
#&gt;     }
#&gt;     else {
#&gt;         stop(paste("Cannot parse swe:elementType, only children of type", 
#&gt;             sweSimpleDataRecordName, "and", sweDataRecordName, 
#&gt;             "are supported!"))
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:encoding`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .textBlock &lt;- xml2::xml_child(x = obj, search = sweTextBlockName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .textEncoding &lt;- xml2::xml_child(x = obj, search = sweTextEncodingName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     if (!(is.na(.textBlock))) {
#&gt;         .tb &lt;- parseTextBlock(.textBlock)
#&gt;         return(.tb)
#&gt;     }
#&gt;     else if (!(is.na(.textEncoding))) {
#&gt;         .tb &lt;- parseTextEncoding(.textEncoding)
#&gt;         return(.tb)
#&gt;     }
#&gt;     else {
#&gt;         stop(paste("Cannot parse swe:encoding, only", sweTextBlockName, 
#&gt;             "and", sweTextEncodingName, "are supported!"))
#&gt;     }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:values`
#&gt; function (values, fields, encoding, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Parsing swe:values using", toString(encoding), 
#&gt;             "and", length(fields), "fields:", toString(names(fields)), 
#&gt;             "\n")
#&gt;     if (!(inherits(encoding, "SweTextBlock") || inherits(encoding, 
#&gt;         "SweTextEncoding"))) {
#&gt;         stop("Handling for given encoding not implemented!")
#&gt;     }
#&gt;     .converters &lt;- sosDataFieldConverters(sos)
#&gt;     .blockLines &lt;- strsplit(x = xml2::xml_text(x = values), split = encoding@blockSeparator)
#&gt;     .tokenLines &lt;- sapply(.blockLines, strsplit, split = encoding@tokenSeparator)
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Parsing values from lines: ", toString(.tokenLines), 
#&gt;             "\n")
#&gt;     .tempId = "tempID"
#&gt;     .data &lt;- data.frame(seq(1, length(.tokenLines)))
#&gt;     names(.data) &lt;- .tempId
#&gt;     .fieldCount &lt;- length(fields)
#&gt;     for (.currentFieldIdx in seq(1, .fieldCount)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Processing field index", .currentFieldIdx, 
#&gt;                 "of", .fieldCount, "\n")
#&gt;         .currentValues &lt;- sapply(.tokenLines, "[[", .currentFieldIdx)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Current values: ", toString(.currentValues), 
#&gt;                 "\n")
#&gt;         .currentField &lt;- fields[[.currentFieldIdx]]
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Parsing field", paste(.currentField), 
#&gt;                 "\n")
#&gt;         .fieldDefinition &lt;- .currentField[[.sosParseFieldDefinition]]
#&gt;         .method &lt;- .converters[[.fieldDefinition]]
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] Using converter:\n")
#&gt;             print(.method)
#&gt;         }
#&gt;         if (is.null(.method)) {
#&gt;             if (!is.na(.currentField[.sosParseFieldUOM])) {
#&gt;                 .method &lt;- .converters[[.currentField[[.sosParseFieldUOM]]]]
#&gt;                 if (is.null(.method)) {
#&gt;                   warning(paste("No converter for the unit of measurement ", 
#&gt;                     .currentField[[.sosParseFieldUOM]], " with the definition ", 
#&gt;                     .currentField[[.sosParseFieldDefinition]], 
#&gt;                     "! Trying a default, but you can add one when creating a SOS using", 
#&gt;                     "SosDataFieldConvertingFunctions().\n"))
#&gt;                   .method &lt;- .converters[["fallBack"]]
#&gt;                 }
#&gt;             }
#&gt;             else {
#&gt;                 warning(paste("No converter found for the given field", 
#&gt;                   toString(.currentField)))
#&gt;             }
#&gt;         }
#&gt;         if (is.null(.method)) {
#&gt;             warning(paste("No converter found! Using field as is:", 
#&gt;                 as.character(fields[[.currentFieldIdx]]), "\n"))
#&gt;         }
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] Using converter function:\n")
#&gt;             show(.method)
#&gt;         }
#&gt;         .currentValues &lt;- .method(x = .currentValues, sos = sos)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Binding additional data.frame for", 
#&gt;                 .currentField[[.sosParseFieldName]], "-- value range", 
#&gt;                 toString(range(.currentValues)), "\n")
#&gt;         .newData &lt;- data.frame(.currentValues)
#&gt;         .newDataName &lt;- .currentField[[.sosParseFieldName]]
#&gt;         names(.newData) &lt;- .cleanupColumnName(.newDataName)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Added column name:", names(.newData), 
#&gt;                 "\n")
#&gt;         .data &lt;- cbind(.data, .newData)
#&gt;         if (verbose) {
#&gt;             cat("[parseValues] The new bound data frame:\n")
#&gt;             str(.data)
#&gt;         }
#&gt;         .addAttrs &lt;- as.list(.currentField)
#&gt;         names(.addAttrs) &lt;- .sosParseFieldReadable[names(.currentField)]
#&gt;         .lastColumn &lt;- dim(.data)[[2]]
#&gt;         .oldAttrs &lt;- attributes(.data[, .lastColumn])
#&gt;         attributes(.data[, .lastColumn]) &lt;- c(as.list(.oldAttrs), 
#&gt;             .addAttrs)
#&gt;         if (verbose) 
#&gt;             cat("[parseValues] Added attributes to new data:", 
#&gt;                 toString(.addAttrs), "[ names: ", toString(names(.addAttrs)), 
#&gt;                 "]", "\n[parseValues] Old attributes list is", 
#&gt;                 toString(.oldAttrs), "\n[parseValues] New attributes list is", 
#&gt;                 toString(attributes(.data[, .lastColumn])), "\n")
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseValues] Removing temporary first column\n")
#&gt;     .data &lt;- .data[, !colnames(.data) %in% .tempId]
#&gt;     if (verbose) {
#&gt;         cat("[parseValues] returning final data frame:\n")
#&gt;         str(.data)
#&gt;     }
#&gt;     return(.data)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Position`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .rF &lt;- xml2::xml_attr(x = obj, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseSwePosition] with referenceFrame", .rF, "\n")
#&gt;     .location &lt;- xml2::xml_child(x = obj, search = sweLocationName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .parser &lt;- sosParsers(sos)[[sweLocationName]]
#&gt;     .pos &lt;- .parser(.location, sos = sos, verbose = verbose)
#&gt;     .oldAttrs &lt;- attributes(.pos)
#&gt;     attributes(.pos) &lt;- c(.oldAttrs, list(referenceFrame = .rF))
#&gt;     return(.pos)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:location`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .vector &lt;- xml2::xml_child(x = obj, search = sweVectorName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .id &lt;- xml2::xml_attr(x = obj, attr = "id")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweLocation] with id", .id, "\n")
#&gt;     .parser &lt;- sosParsers(sos)[[sweVectorName]]
#&gt;     location &lt;- .parser(.vector, sos = sos, verbose = verbose)
#&gt;     return(location)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Vector`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .children &lt;- xml2::xml_find_all(x = obj, xpath = sweCoordinateName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .parser &lt;- sosParsers(sos)[[sweCoordinateName]]
#&gt;     .vector &lt;- lapply(X = .children, FUN = .parser, sos = sos, 
#&gt;         verbose = verbose)
#&gt;     names(.vector) &lt;- sapply(.vector, function(current) {
#&gt;         return(current$axisID)
#&gt;     })
#&gt;     if (verbose) 
#&gt;         cat("[parseSweVector] parsed vector with coordinates: ", 
#&gt;             toString(names(.vector)), "\n")
#&gt;     return(.vector)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:coordinate`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .name &lt;- xml2::xml_attr(x = obj, attr = "name")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] with name", .name, "\n")
#&gt;     .quantity &lt;- xml2::xml_child(x = obj, search = sweQuantityName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .axisID &lt;- xml2::xml_attr(x = .quantity, attr = "axisID")
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] axisID: ", .axisID, "\n")
#&gt;     .uomNode &lt;- xml2::xml_child(x = .quantity, search = sweUomName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .uomCode &lt;- xml2::xml_attr(x = .uomNode, attr = "code", ns = SosAllNamespaces())
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] uomCode: ", .uomCode, "\n")
#&gt;     .valueNode &lt;- xml2::xml_child(x = .quantity, search = sweValueName, 
#&gt;         ns = SosAllNamespaces())
#&gt;     .value &lt;- as.double(xml2::xml_text(x = .valueNode))
#&gt;     if (verbose) 
#&gt;         cat("[parseSweCoordinate] value: ", .value, "\n")
#&gt;     return(list(name = .name, axisID = .axisID, uomCode = .uomCode, 
#&gt;         value = .value))
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:GeometryObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:GeometryObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CategoryObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:CategoryObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CountObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:CountObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TruthObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:TruthObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TemporalObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:TemporalObservatio is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ComplexObservation`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     warning("Parsing of om:ComplexObservation is not implemented!")
#&gt;     return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/csv`
#&gt; function (obj, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Processing CSV...\n")
#&gt;     .lines &lt;- strsplit(x = obj, split = "\n")[[1]]
#&gt;     .data &lt;- do.call(what = "strsplit", args = list(.lines, split = ","))
#&gt;     .names &lt;- .data[[1]]
#&gt;     .newNames &lt;- c()
#&gt;     for (.n in .names) {
#&gt;         .newNames &lt;- c(.newNames, gsub(pattern = "\"", replacement = "", 
#&gt;             x = .n))
#&gt;     }
#&gt;     .names &lt;- .newNames
#&gt;     .rows &lt;- length(.data)
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Got", .rows, "lines of data.\n")
#&gt;     if (.rows == 1) {
#&gt;         warnings(paste("Received just one line of data: ", .data, 
#&gt;             "\n"))
#&gt;         return(.data[[1]])
#&gt;     }
#&gt;     .df &lt;- NULL
#&gt;     for (.r in seq(2, .rows)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseCSV] Processing row in CSV:", .data[[.r]], 
#&gt;                 "\n")
#&gt;         .row.df &lt;- as.data.frame(.data[[.r]][1])
#&gt;         names(.row.df) &lt;- .names[[1]]
#&gt;         for (i in seq(2, length(.names))) {
#&gt;             .df &lt;- as.data.frame(.data[[.r]][i])
#&gt;             names(.df) &lt;- .names[[i]]
#&gt;             .row.df &lt;- cbind(.row.df, .df)
#&gt;         }
#&gt;         if (is.null(.df)) 
#&gt;             .df &lt;- .row.df
#&gt;         else .df &lt;- do.call(rbind, list(.df, .row.df))
#&gt;     }
#&gt;     if (verbose) 
#&gt;         cat("[parseCSV] Done.\n")
#&gt;     return(.df)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml;subtype="om/1.0.0"`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`application/vnd.google-earth.kml+xml`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseKML] Processing KML... returning raw object!\n")
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $kml
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     if (verbose) 
#&gt;         cat("[parseKML] Processing KML... returning raw object!\n")
#&gt;     return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml`
#&gt; function (obj, sos, verbose = FALSE) 
#&gt; {
#&gt;     .om &lt;- NULL
#&gt;     .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt;     .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;     if (!is.null(.parsingFunction)) {
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Matched name for parser is", .name, 
#&gt;                 "\n")
#&gt;         .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;         if (verbose) 
#&gt;             cat("[parseOM] Done parsing\n")
#&gt;     }
#&gt;     else {
#&gt;         warning(paste("[parseOM] No parsing function for given element", 
#&gt;             .name))
#&gt;     }
#&gt;     return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
</div># NOT RUN {
# Replace an encoding function
myEncoding <- function(object, v) {
	return(str(object))
}

sos = SOS(url = "http://mysos.com/sos",
		encoders = SosEncodingFunctions("POST" = myPostEncoding))

# Use custom converting function and connection method. This mechanism works the
# same for encoders and decoders.
myConverters <- SosDataFieldConvertingFunctions(
	"myNumericUnit" = sosConvertDouble,
mySos <- SOS(sos.url, binding = "KVP", dataFieldConverters = myConverters)
sosDataFieldConverters(mySos)

# inspecting XML using dummy parsing function
sos = SOS(url = "http://mysos.com/sos", parsers = SosDisabledParsers)
describeSensor(sos, sosProcedures(sos)[[1]])
# }
<div class='input'>
<span class='co'># a list of example services</span>
<span class='fu'>SosExampleServices</span>()</div><div class='output co'>#&gt; $`NOAA National Data Buoy Center`
#&gt; [1] "https://sdf.ndbc.noaa.gov/sos/server.php"
#&gt; 
#&gt; $`WSV PegelOnline`
#&gt; [1] "www.pegelonline.wsv.de/webservices/gis/sos"
#&gt; </div><div class='input'>
<span class='co'># a named list of all defaults</span>
<span class='fu'>SosDefaults</span>()</div><div class='output co'>#&gt; $sosDefaultCharacterEncoding
#&gt; [1] "UTF-8"
#&gt; 
#&gt; $sosDefaultDescribeSensorOutputFormat
#&gt; [1] "text/xml;subtype=\"sensorML/1.0.1\""
#&gt; 
#&gt; $sosDefaultGetCapSections
#&gt; [1] "All"
#&gt; 
#&gt; $sosDefaultGetCapAcceptFormats
#&gt; [1] "text/xml"
#&gt; 
#&gt; $sosDefaultGetCapOwsVersion
#&gt; [1] "1.1.0"
#&gt; 
#&gt; $sosDefaultGetObsResponseFormat
#&gt; [1] "text/xml;subtype=\"om/1.0.0\""
#&gt; 
#&gt; $sosDefaultTimeFormat
#&gt; [1] "%Y-%m-%dT%H:%M:%OS"
#&gt; 
#&gt; $sosDefaultFilenameTimeFormat
#&gt; [1] "%Y-%m-%d_%H-%M-%OS"
#&gt; 
#&gt; $sosDefaultTempOpPropertyName
#&gt; [1] "om:samplingTime"
#&gt; 
#&gt; $sosDefaultTemporalOperator
#&gt; [1] "TM_During"
#&gt; 
#&gt; $sosDefaultSpatialOpPropertyName
#&gt; [1] "urn:ogc:data:location"
#&gt; 
#&gt; $sosDefaultColumnNameFeatureIdentifier
#&gt; [1] "feature"
#&gt; 
#&gt; $sosDefaultColumnNameLat
#&gt; [1] "lat"
#&gt; 
#&gt; $sosDefaultColumnNameLon
#&gt; [1] "lon"
#&gt; 
#&gt; $sosDefaultColumnNameSRS
#&gt; [1] "SRS"
#&gt; 
#&gt; $sosDefaultReferenceFrameSensorDescription
#&gt; [1] "urn:ogc:def:crs:EPSG:4326"
#&gt; </div><div class='input'>
# replace the parsing functions with the default ones
</div><span class='co'># NOT RUN {</span>
<span class='no'>sos</span> <span class='kw'>&lt;-</span> <span class='fu'>SosResetParsingFunctions</span>(<span class='no'>sos</span>)
<span class='co'># }</span><div class='input'>
<span class='co'># parsing options used by xml2</span>
<span class='fu'>SosDefaultParsingOptions</span>()</div><div class='output co'>#&gt; [1] "RECOVER"</div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#value">Value</a></li>

      <li><a href="#references">References</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Daniel Nuest.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.9000.</p>
</div>
      </footer>
   </div>

  

  </body>
</html>

