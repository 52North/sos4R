<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Default Parameter Settings and Handling Functions — Defaults • sos4R</title>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- sticky kit -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>



<meta property="og:title" content="Default Parameter Settings and Handling Functions — Defaults" />

<meta property="og:description" content="These values are default parameters and handling functions for connections and requests to, as well as response processing of ansers from, Sensor Observation Services. These allow to simplify a SOS connection for the most common use cases and non-expert users." />
<meta name="twitter:card" content="summary" />



<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">sos4R</a>
<<<<<<< HEAD
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.4.0.9002</span>
=======
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.3.1</span>
>>>>>>> dev
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/sos4R-vignette-01-quickstart.html">sos4R: Accessing Sensor Observation Services from R - Quickstart</a>
    </li>
    <li>
      <a href="../articles/sos4R-vignette-02-ogc-sos.html">sos4R: OGC SWE and SOS</a>
    </li>
    <li>
      <a href="../articles/sos4R-vignette-03-sos-operations.html">sos4R: SOS Operations</a>
    </li>
    <li>
      <a href="../articles/sos4R-vignette-04-extensions.html">sos4R: Extending package functions and advanced configuration</a>
    </li>
    <li>
      <a href="../articles/sos4R-vignette-05-wrapper-functions.html">sos4R: Wrapper Functions for easier SOS access</a>
    </li>
    <li>
      <a href="../articles/sos4R-vignette-99-services.html">sos4R: List of SOSs</a>
    </li>
  </ul>
</li>
<li>
  <a href="../DEV-README.html">Developer Docs</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/52North/sos4R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Default Parameter Settings and Handling Functions</h1>
    
    <div class="hidden name"><code>Defaults.Rd</code></div>
    </div>

    <div class="ref-description">
    
    <p>These values are default parameters and handling functions for connections and requests to, as well as response processing of ansers from, Sensor Observation Services. These allow to simplify a SOS connection for the most common use cases and non-expert users.</p>
    
    </div>

    <pre class="usage"><span class='fu'>SosDefaultBinding</span>()

<span class='fu'>SosParsingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))
<span class='fu'>SosEncodingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))
<span class='fu'>SosDataFieldConvertingFunctions</span>(<span class='no'>...</span>, <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>), <span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/character'>character</a></span>(<span class='fl'>0</span>))

<span class='fu'>SosDisabledParsers</span>()

<span class='fu'>SosDefaults</span>()

<span class='fu'>SosResetParsingFunctions</span>(<span class='no'>sos</span>)

<span class='fu'>SosDefaultDCPs</span>()

<span class='fu'>SosDefaultParsingOptions</span>()</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>&#8230;</th>
      <td><p>Named references to functions to be used for the respective element during parsing, encoding oder conversion, e.g. <code>"myUnit" = myUnitParser</code>.</p></td>
    </tr>
    <tr>
      <th>include</th>
      <td><p>A list of names of elements whose functions shall be included in the returned list, e.g. <code>include = c("GetObservation", "DescribeSensor")</code>. This inclusion is done <b>after</b> replacing the default functions based on the <code>...</code> argument.</p></td>
    </tr>
    <tr>
      <th>exclude</th>
      <td><p>A list of names of elements whose functions shall be excluced in the returned list, e.g. <code>exclude = c("DescribeSensor")</code>. This exclusion is done <b>after</b> replacing the default functions based on the <code>...</code> argument.</p></td>
    </tr>
    <tr>
      <th>sos</th>
      <td><p>An object of class <code>SOS</code>.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The default values are strongly related to what is actually implemented in the package, but also often resemble the (hopefully) most common use cases.</p>
<p>Some defaults are accessed directly, others should be accessed using a function. The latter is required for cases where a runtime evaluation is needed, e.g. for default values of construction functions.</p>
<p>A special case are the functions to access the default functions for specific purposes, which are the parsing functions, the encoding functions and the field converting functions. See the examples on how to use them.</p>
<p>The function <code>SosDisabledParsers</code> can be used to use no parsing at all (despite the parsing for the capabilities response, which is required for establishing a connection to a SOS. This function is helpful to inspect the unprocessed responses from a service.</p>
<p>The function <code>SosResetParsingFunctions</code> can be used to replace the included parsing functions of a <code>SOS</code> object with the default ones. This is even useful for development of the default parsing functions.</p>
<p><b>The default parameter values are:</b></p><dl class='dl-horizontal'>
	<dt>sosDefaultCharacterEncoding</dt><dd><p><code>\Sexpr[results=verbatim,stage=render]{sosDefaultCharacterEncoding}</code></p></dd> % "UTF-8"
	<dt>sosDefaultDescribeSensorOutputFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultDescribeSensorOutputFormat}</code></p></dd>
	<dt>sosDefaultGetCapSections</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapSections}</code></p></dd> % c("All")
	<dt>sosDefaultGetCapAcceptFormats</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapAcceptFormats}</code></p></dd> % c("text/xml")
	<dt>sosDefaultGetCapOwsVersion</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetCapOwsVersion}</code></p></dd> % "1.1.0"
	<dt>sosDefaultGetObsResponseFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultGetObsResponseFormat}</code></p></dd>
	<dt>sosDefaultTimeFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTimeFormat}</code></p></dd> % "%Y-%m-%dT%H:%M:%OS"
	<dt>sosDefaultFilenameTimeFormat</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultFilenameTimeFormat}</code></p></dd> %
	<dt>sosDefaultTempOpPropertyName</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTempOpPropertyName}</code></p></dd> % "om:samplingTime"
	<dt>sosDefaultTemporalOperator</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultTemporalOperator}</code></p></dd> % SosSupportedTemporalOperators()[[ogcTempOpTMDuringName]]
	<dt>sosDefaultSpatialOpPropertyName</dt><dd><p><code>\Sexpr[results=text,stage=render]{sosDefaultSpatialOpPropertyName}</code></p></dd> % "urn:ogc:data:location"
</dl>
    <p>The <b>default parsing functions</b> can be replaced for a variety of XML elements, so that you only need to replace the parts of the parsing that really must be changed. Be aware that inclusion and exclusion are performed after merging the given functions with the defaults!</p>
<p><b>Example Services:</b> This list contains a few SOS instances that were tested (to different degress) with <span class="pkg">sos4R</span>. The package authors do not maintain these services, so no guarantee can be given that these are usable.</p>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The default value of the respective setting or parameter. This can be a list, especially a named list of functions.</p>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p><code><a href='Constants.html'>Constants</a></code></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># simple default values</span>
<span class='fu'>show</span>(<span class='no'>sosDefaultCharacterEncoding</span>)</div><div class='output co'>#&gt; [1] "UTF-8"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultDescribeSensorOutputFormat</span>)</div><div class='output co'>#&gt; [1] "text/xml;subtype=\"sensorML/1.0.1\""</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapAcceptFormats</span>)</div><div class='output co'>#&gt; [1] "text/xml"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapOwsVersion</span>)</div><div class='output co'>#&gt; [1] "1.1.0"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetCapSections</span>)</div><div class='output co'>#&gt; [1] "All"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultGetObsResponseFormat</span>)</div><div class='output co'>#&gt; [1] "text/xml;subtype=\"om/1.0.0\""</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultSpatialOpPropertyName</span>)</div><div class='output co'>#&gt; [1] "urn:ogc:data:location"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTempOpPropertyName</span>)</div><div class='output co'>#&gt; [1] "om:samplingTime"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTemporalOperator</span>)</div><div class='output co'>#&gt; [1] "TM_During"</div><div class='input'><span class='fu'>show</span>(<span class='no'>sosDefaultTimeFormat</span>)</div><div class='output co'>#&gt; [1] "%Y-%m-%dT%H:%M:%OS%z"</div><div class='input'><span class='fu'>SosDefaultBinding</span>()</div><div class='output co'>#&gt; [1] "POX"</div><div class='input'>
</div><span class='co'># NOT RUN {</span>
<span class='co'># usage of defaults in construction method for SOS class</span>
<span class='no'>sos</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='SOS.html'>SOS</a></span>(<span class='st'>"http://mysos.com/sos"</span>, <span class='kw'>binding</span> <span class='kw'>=</span> <span class='fu'>SosDefaultBinding</span>(),
                <span class='kw'>timeFormat</span> <span class='kw'>=</span> <span class='no'>sosDefaultTimeFormat</span>)

<span class='co'># functions to disable all parsing</span>
<<<<<<< HEAD
<span class='fu'>SosDisabledParsers</span>()
<span class='co'># }</span><div class='input'>

=======
<span class='fu'>SosDisabledParsers</span>()</div><div class='output co'>#&gt; $GetCapabilities
#&gt; function(obj, sos) {
#&gt;   if (sos@version == sos100_version){
#&gt;     .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;   }
#&gt;   else if (sos@version == sos200_version){
#&gt;     .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function(obj) {
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservation
#&gt; function(obj) {
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function(obj) {
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function(obj) {
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
>>>>>>> dev
<span class='co'># Replace a parsing function</span>
<span class='no'>myER</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>xml</span>) {
        <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/function'>return</a></span>(<span class='st'>"EXCEPTION!!!11"</span>)
}
<<<<<<< HEAD
<span class='no'>myParsingFunctions</span> <span class='kw'>&lt;-</span> <span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>)

<span class='co'># use inclusion and exclusion, important: even the just added function needs to</span>
<span class='co'># be included manually!</span>
<span class='no'>myParsingFunctions</span> <span class='kw'>&lt;-</span> <span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>,
        <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>, <span class='st'>"ExceptionReport"</span>))

<span class='no'>myParsingFunctions</span> <span class='kw'>&lt;-</span> <span class='fu'>SosParsingFunctions</span>(<span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>))</div># NOT RUN {
=======
<span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>)</div><div class='output co'>#&gt; $ExceptionReport
#&gt; function(xml) {
#&gt; 	return("EXCEPTION!!!11")
#&gt; }
#&gt; &lt;environment: 0x564ebe6e8000&gt;
#&gt; 
#&gt; $GetCapabilities
#&gt; function(obj, sos) {
#&gt;   if (sos@version == sos100_version){
#&gt;     .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;   }
#&gt;   else if (sos@version == sos200_version){
#&gt;     .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseSensorML] Starting... \n")
#&gt; 
#&gt;   .id &lt;- .smlIdentifier(obj, "uniqueID", verbose = verbose)
#&gt;   .shortName &lt;- .smlIdentifier(obj, "shortName", verbose = verbose)
#&gt;   .descrNode &lt;- xml2::xml_find_first(x = obj,
#&gt;                                      xpath = .smlXPathDescription,
#&gt;                                      ns = SosAllNamespaces())
#&gt;   .description &lt;- xml2::xml_text(x = .descrNode)
#&gt; 
#&gt;   if (verbose) cat("[parseSensorML] Got ID", .id,
#&gt;                    "and shortName", .shortName,
#&gt;                    "and description", .description, "\n")
#&gt; 
#&gt;   # bounded by
#&gt;   if (verbose) cat("[parseSensorML] Parsing boundedBy from", .smlXPathObservedBBox, "\n")
#&gt;   .observedBBox &lt;- xml2::xml_find_first(x = obj,
#&gt;                                         xpath = .smlXPathObservedBBox,
#&gt;                                         ns = SosAllNamespaces())
#&gt;   if (!is.na(.observedBBox)) {
#&gt;     .referenceFrame &lt;- xml2::xml_attr(x = .observedBBox, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;     .llVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox,
#&gt;                                              search = paste0(sweUpperCornerName, "/", sweVectorName),
#&gt;                                              ns = SosAllNamespaces()),
#&gt;                              sos = sos, verbose = verbose)
#&gt;     .uuVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox,
#&gt;                                              search = paste0(sweLowerCornerName, "/", sweVectorName),
#&gt;                                              ns = SosAllNamespaces()),
#&gt;                              sos = sos, verbose = verbose)
#&gt;     .bb &lt;- matrix(c(.llVector[["x"]][["value"]],
#&gt;                     .llVector[["y"]][["value"]],
#&gt;                     .uuVector[["x"]][["value"]],
#&gt;                     .uuVector[["y"]][["value"]]),
#&gt;                   ncol = 2,
#&gt;                   dimnames = list(c("coords.lon", "coords.lat"),
#&gt;                                   c("min", "max")))
#&gt;     .oldAttrs &lt;- attributes(.bb)
#&gt;     attributes(.bb) &lt;- c(.oldAttrs,
#&gt;                          list(referenceFrame = .referenceFrame))
#&gt; 
#&gt;     if (verbose) cat("[parseSensorML] Parsed bounding box: ", toString(.bb), "\n")
#&gt;   }
#&gt;   else {
#&gt;     .bb &lt;- matrix()
#&gt;     if (verbose) cat("[parseSensorML] No boundedBy element found, bbox is ", .bb, "\n")
#&gt;   }
#&gt; 
#&gt;   # coordinates
#&gt;   if (verbose) cat("[parseSensorML] Parsing coordinates from", .smlXPathPosition, "\n")
#&gt;   .xmlPosition &lt;- xml2::xml_find_first(x = obj,
#&gt;                                        xpath = .smlXPathPosition,
#&gt;                                        ns = SosAllNamespaces())
#&gt;   if (!is.na(.xmlPosition)) {
#&gt;     .position &lt;- parseSwePosition(.xmlPosition,
#&gt;                                   sos = sos,
#&gt;                                   verbose = verbose)
#&gt;     .referenceFrame = attributes(.position)[["referenceFrame"]]
#&gt;     .uom &lt;- lapply(.position, "[[", "uomCode")
#&gt;     names(.uom) &lt;- lapply(.position, "[[", "axisID")
#&gt;     .name &lt;- lapply(.position, "[[", "name")
#&gt;     names(.name) &lt;- lapply(.position, "[[", "axisID")
#&gt; 
#&gt;     .values &lt;- lapply(.position, "[[", "value")
#&gt;     names(.values) &lt;- lapply(.position, "[[", "axisID")
#&gt;     if (any(is.na(names(.values)))) {
#&gt;       warning("[parseSensorML] No axisID given, cannot name data.frame with them, trying 'name'.")
#&gt;       names(.values) &lt;- lapply(.position, "[[", "name")
#&gt;     }
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseSensorML] names: ", names(.values), "\n")
#&gt;       cat("[parseSensorML] values: ", toString(.values),	"\n")
#&gt;     }
#&gt; 
#&gt;     .coords &lt;- data.frame(.values)
#&gt;     .oldAttrs &lt;- attributes(.coords)
#&gt;     attributes(.coords) &lt;- c(as.list(.oldAttrs),
#&gt;                              list(referenceFrame = .referenceFrame,
#&gt;                                   uom = .uom, name = .name))
#&gt; 
#&gt;     if (!is.na(.id))
#&gt;       row.names(.coords) &lt;- .id
#&gt;     if (verbose) cat("[parseSensorML]  row names: ", row.names(.coords),
#&gt;                     "\n")
#&gt;   }
#&gt;   else {
#&gt;     .coords &lt;- data.frame()
#&gt;   }
#&gt; 
#&gt;   # create instance
#&gt;   .sml = SensorML(xml = obj,
#&gt;                   coords = .coords,
#&gt;                   id = .id,
#&gt;                   name = .shortName,
#&gt;                   description = .description,
#&gt;                   boundedBy = .bb)
#&gt; 
#&gt;   if (verbose) cat("[parseSensorML]  Done: ", toString(.sml), "\n")
#&gt; 
#&gt;   return(.sml)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservation
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (sos@verboseOutput) {
#&gt;     cat("[parseGetObservationResponse] entering... \n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   .observationsXML &lt;- xml2::xml_find_all(x = obj,
#&gt;                                          xpath = "sos20:observationData",
#&gt;                                          ns = SosAllNamespaces(version = sos200_version))
#&gt;   featureCache &lt;- list()
#&gt;   .observations &lt;- sapply(.observationsXML,
#&gt;                          parseObservation_2.0,
#&gt;                          sos = sos,
#&gt;                          featureCache = featureCache)
#&gt; 
#&gt;   return(.observations)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetFeatureOfInterestResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt; 
#&gt;   if (sos@verboseOutput) {
#&gt;     cat("[parseGetFeatureOfInterestResponse] entering... \n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   .featureXML &lt;- xml2::xml_find_all(x = obj,
#&gt;                                     xpath = "sos20:featureMember",
#&gt;                                     SosAllNamespaces(version = sos200_version))
#&gt;   .foi = sapply(.featureXML, .parseFeatureMember, sos = sos)
#&gt;   return(.foi)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function(obj, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseOwsExceptionReport] Starting ...\n")
#&gt;   .docRoot &lt;- xml2::xml_root(x = obj)
#&gt; 
#&gt;   .version &lt;- xml2::xml_attr(x = .docRoot, attr = "version")
#&gt;   .lang &lt;- xml2::xml_attr(x = .docRoot, attr = "lang", default = NA_character_)
#&gt; 
#&gt;   .exceptionsXML &lt;- xml2::xml_find_all(x = .docRoot,
#&gt;                                        xpath = paste0("//", owsExceptionName),
#&gt;                                        ns = SosAllNamespaces())
#&gt; 
#&gt;   .exceptions = sapply(.exceptionsXML, parseOwsException)
#&gt;   if (verbose) cat("[parseOwsExceptionReport]", length(.exceptions), "exceptions.")
#&gt; 
#&gt;   .report &lt;- OwsExceptionReport(version = .version, lang = .lang, exceptions = .exceptions)
#&gt; 
#&gt;   return(.report)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetDataAvailabilityResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse]")
#&gt; 
#&gt;   if (sos@version != sos200_version) {
#&gt;     stop(paste0("[parseGetDataAvailabilityResponse] SOS version 2.0 required! Received '",
#&gt;                 sos@version, "'"))
#&gt;   }
#&gt; 
#&gt;   .gdaMembers &lt;- xml2::xml_find_all(x = obj, xpath = sosGDAMemberName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse] with", length(.gdaMembers), "element(s).\n")
#&gt;   phenTimeCache &lt;- list()
#&gt;   .parsedGDAMembers &lt;- lapply(.gdaMembers, .parseGDAMember, sos, phenTimeCache, verbose)
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse] Done. Processed", length(.parsedGDAMembers),
#&gt;                    "elements")
#&gt;   return(.parsedGDAMembers)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Measurement`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseMeasurement]\n")
#&gt; 
#&gt;   .samplingTimeXml &lt;- xml2::xml_child(x = obj,
#&gt;                                       search = omSamplingTimeName,
#&gt;                                       ns = SosAllNamespaces())
#&gt;   .samplingTime &lt;- parseTime(obj = .samplingTimeXml,
#&gt;                              format = sosTimeFormat(sos),
#&gt;                              verbose = verbose)
#&gt; 
#&gt;   # 52N SOS only returns om:Measurements (!) with procedure ids and observed
#&gt;   # properties in xlink:href
#&gt;   .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, search = omProcedureName, ns = SosAllNamespaces()), attr = "href")
#&gt;   .observedProperty &lt;- SwePhenomenonProperty(
#&gt;     href = xml2::xml_attr(x = xml2::xml_child(x = obj, search = omObservedPropertyName, ns = SosAllNamespaces()), attr = "href"))
#&gt; 
#&gt;   .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()), sos = sos,
#&gt;                                  verbose = verbose)
#&gt; 
#&gt;   # must be GmlMeasure
#&gt;   .result &lt;- parseMeasure(xml2::xml_child(x = obj, search = omResultName, ns = SosAllNamespaces()))
#&gt; 
#&gt;   # TODO optionals elements for OmMeasurement
#&gt;   #.metadata
#&gt;   #.resultTime
#&gt;   #.resultQuality
#&gt;   #.parameter
#&gt; 
#&gt;   .measurement &lt;- OmMeasurement(samplingTime = .samplingTime,
#&gt;                                 procedure = .procedure, observedProperty = .observedProperty,
#&gt;                                 featureOfInterest = .featureOfInterest, result = .result)
#&gt; 
#&gt;   return(.measurement)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:member`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   # a member can only have one child element
#&gt;   if (xml2::xml_length(x = obj) &gt;= 1) {
#&gt;     .child &lt;- xml2::xml_child(obj)
#&gt;     if (verbose) cat("[parseObservationProperty] Parsing child of member:",
#&gt;                      xml2::xml_name(x = .child, ns = SosAllNamespaces()), "\n")
#&gt;     .mResult &lt;- parseOM(.child, sos, verbose)
#&gt;   }
#&gt;   else {
#&gt;     # no child, try href attribute
#&gt;     if (verbose) cat("[parseObservationProperty] Member has no direct child!\n")
#&gt; 
#&gt;     .href &lt;- xml2::xml_attr(x = obj, attr = "href", default = NA_character_)
#&gt;     if (!is.na(.href)) {
#&gt;       warning("Only reference was returned:", .href)
#&gt;       .mResult &lt;- OmObservationProperty(href = .href)
#&gt;     }
#&gt;     else {
#&gt;       warning("No observation found!")
#&gt;       .mResult &lt;- OmObservationProperty()
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   return(.mResult)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Observation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .id &lt;- xml2::xml_attr(x = obj, attr = "id", default = NA_character_)
#&gt;   if (verbose) cat("[parseObservation]", .id, "\n")
#&gt; 
#&gt;   # 52N SOS only returns om:Observation with procedure ids xlink:href
#&gt;   .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj,
#&gt;                                                    search = omProcedureName,
#&gt;                                                    ns = SosAllNamespaces()),
#&gt;                                attr = "href",
#&gt;                                default = NA_character_)
#&gt; 
#&gt;   .observedProperty &lt;- parsePhenomenonProperty(xml2::xml_child(x = obj, search = omObservedPropertyName, ns = SosAllNamespaces()),
#&gt;                                                verbose = verbose)
#&gt; 
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omSamplingTimeName, ns = SosAllNamespaces()))) {
#&gt;     .samplingTime &lt;- parseTime(obj = xml2::xml_child(x = obj,
#&gt;                                                      search = omSamplingTimeName,
#&gt;                                                      ns = SosAllNamespaces()),
#&gt;                                format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;   } else {
#&gt;     warning("om:samplingTime is mandatory in om:Observation, but is missing!")
#&gt;     .samplingTime &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()))) {
#&gt;     .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()),
#&gt;                                    sos = sos, verbose = verbose)
#&gt;   } else {
#&gt;     warning("om:featureOfInterest is mandatory in om:Observation, but is missing!")
#&gt;     .featureOfInterest &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   # result parser is exchangeable
#&gt;   .resultParsingFunction &lt;- sosParsers(sos)[[omResultName]]
#&gt;   .result &lt;- .resultParsingFunction(xml2::xml_child(x = obj, search = omResultName, ns = SosAllNamespaces()), sos, verbose)
#&gt; 
#&gt;   # optional elements
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omResultTimeName, ns = SosAllNamespaces()))) {
#&gt;     .resultTime &lt;- parseTime(obj = xml2::xml_child(x = obj, search = omResultTimeName, ns = SosAllNamespaces()),
#&gt;                              format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;   }
#&gt;   else {
#&gt;     .resultTime &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   # TODO optionals elements for OmObservation
#&gt;   #.metadata
#&gt;   #.resultQuality
#&gt;   #.parameter
#&gt;   #.metadata
#&gt; 
#&gt;   .obs &lt;- OmObservation(samplingTime = .samplingTime,
#&gt;                         procedure = .procedure,
#&gt;                         observedProperty = .observedProperty,
#&gt;                         featureOfInterest = .featureOfInterest,
#&gt;                         result = .result)
#&gt; 
#&gt;   return(.obs)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ObservationCollection`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .members &lt;- xml2::xml_find_all(x = obj, xpath = omMemberName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (verbose) cat("[parseObservationCollection] with ", length(.members), "element(s).\n")
#&gt; 
#&gt;   .env &lt;- xml2::xml_child(x = obj, search = paste0(gmlBoundedByName, "/", gmlEnvelopeName))
#&gt;   if (!is.na(.env)) {
#&gt;     .boundedBy &lt;- list(
#&gt;       srsName = xml2::xml_attr(x = .env, attr = "srsName", ns = SosAllNamespaces()),
#&gt;       lowerCorner = xml2::xml_text(x = xml2::xml_child(x = .env, search = gmlLowerCornerName, ns = SosAllNamespaces())),
#&gt;       upperCorner = xml2::xml_text(x = xml2::xml_child(x = .env, search = gmlUpperCornerName, ns = SosAllNamespaces())))
#&gt; 
#&gt;     if (verbose) cat("[parseObservationCollection] Parsed envelope:", toString(.boundedBy), "\n")
#&gt; 
#&gt;     if (sosSwitchCoordinates(sos)) {
#&gt;       warning("Switching coordinates in envelope of ObservationCollection!")
#&gt;       .origLC &lt;- strsplit(x = .boundedBy[["lowerCorner"]], split = " ")
#&gt;       .lC &lt;- paste(.origLC[[1]][[2]], .origLC[[1]][[1]])
#&gt;       .origUC &lt;- strsplit(x = .boundedBy[["upperCorner"]], split = " ")
#&gt;       .uC &lt;- paste(.origUC[[1]][[2]], .origUC[[1]][[1]])
#&gt;       .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, attr = "srsName"),
#&gt;                          lowerCorner = .lC, upperCorner = .uC)
#&gt;     }
#&gt;   }
#&gt;   else {
#&gt;     if (verbose) cat("[parseObservationCollection] Empty envelope!\n")
#&gt;     .boundedBy &lt;- list()
#&gt;   }
#&gt; 
#&gt;   .resultList &lt;- lapply(X = .members, FUN = parseOM, sos = sos, verbose = verbose)
#&gt;   names(.resultList) &lt;- lapply(X = .members, FUN = function(member) {
#&gt;     children &lt;- xml2::xml_children(member)
#&gt;     idOrName &lt;- xml2::xml_attr(children, attr = "id", default = xml2::xml_name(children))
#&gt;     if (length(idOrName) &lt; 1) {
#&gt;       xml2::xml_name(member)
#&gt;     } else {
#&gt;       idOrName
#&gt;     }
#&gt;   })
#&gt; 
#&gt;   if (is.list(.resultList)) {
#&gt;     .obsColl &lt;- OmObservationCollection(members = .resultList,
#&gt;                                         boundedBy = .boundedBy)
#&gt;   }
#&gt;   else {
#&gt;     .obsColl &lt;- OmObservationCollection(members = list(.resultList),
#&gt;                                         boundedBy = .boundedBy)
#&gt;   }
#&gt; 
#&gt;   if (verbose)
#&gt;     cat("[parseObservationCollection] Done. Processed", length(.obsColl),
#&gt;         "elements:", names(.obsColl), "\n")
#&gt; 
#&gt;   return(.obsColl)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:result`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseResult] Starting ...\n")
#&gt;   .result &lt;- NULL
#&gt; 
#&gt;   .children &lt;- xml2::xml_children(x = obj)
#&gt;   if (verbose) cat("[parseResult]", length(.children), " non-text nodes, names:", xml2::xml_name(.children), "\n")
#&gt; 
#&gt;   # Check if remaining element is there
#&gt;   if (length(.children) == 0) {
#&gt;     .children &lt;- xml2::xml_children(x = obj)
#&gt;     stop("Continue implementation here: OM-methods-parsing.R")
#&gt;     cat("[parseResult] No non-text nodes in result, returning NULL.\n")
#&gt; 
#&gt;     #in O&amp;M 2.0 there can be (literal) results of type MeasurementType
#&gt;     .typeAttributValue &lt;- xml2::xml_attr(x = obj, attr = om20ResultTypeAttributeName, default = NA_character_)
#&gt; 
#&gt;     .typeWithQualifiedname &lt;- strsplit(.typeAttributValue, ":")
#&gt; 
#&gt;     .type &lt;- NA_character_
#&gt; 
#&gt;     if (length(.typeWithQualifiedname) &gt; 0) {
#&gt; 
#&gt;       if (length(.typeWithQualifiedname[[1]]) &gt; 1) {
#&gt;         .type &lt;- .typeWithQualifiedname[[1]][2]
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     if (!is.na(.type)) {
#&gt;       if (.type == om20ResultMeasureTypeName) {
#&gt;         return(xml2::xml_text(x = obj))
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     return(NULL)
#&gt;   }
#&gt; 
#&gt;   .name &lt;- xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces())
#&gt;   if (.name == sweDataArrayName) {
#&gt;     if (verbose) cat("[parseResult] Parsing result with swe:DataArray.\n")
#&gt; 
#&gt;     # data array parser is exchangeable
#&gt;     .dataArrayParsingFunction &lt;- sosParsers(sos)[[sweDataArrayName]]
#&gt;     .result &lt;- .dataArrayParsingFunction(.children[[1]], sos, verbose)
#&gt;   }
#&gt;   else if (.name == xmlTextNodeName) {
#&gt;     .result &lt;- as.numeric(xml2::xml_text(x = .children))
#&gt;     if (is.na(.result)) {
#&gt;       .result &lt;- xml2::xml_text(x = .children, trim = TRUE)
#&gt;     }
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseResult] Parsing of given result is NOT supported:",
#&gt;                   xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces()),
#&gt;                   "-- only", sweDataArrayName,
#&gt;                   " or text nodes containing strings or numbers can be parsed."))
#&gt;   }
#&gt; 
#&gt;   if (is.null(.result)) {
#&gt;     stop("[parseResult] result is null! Given result:\n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   if (verbose) cat("[parseResult] Done\n")
#&gt; 
#&gt;   return(.result)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:DataArray`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .elementCount &lt;- xml2::xml_text(xml2::xml_find_first(x = obj,
#&gt;                                                        xpath = "./swe:elementCount/swe:Count/swe:value",
#&gt;                                                        ns = SosAllNamespaces())
#&gt;                                   )
#&gt;   if (verbose) cat("[parseDataArray] Parsing DataArray with", .elementCount, "elements.\n")
#&gt; 
#&gt;   .elementTypeParser &lt;- sosParsers(sos)[[sweElementTypeName]]
#&gt;   .elementTypeXml &lt;- xml2::xml_child(x = obj, search = sweElementTypeName, ns = SosAllNamespaces())
#&gt;   .fields &lt;- .elementTypeParser(obj = .elementTypeXml,
#&gt;                                 sos = sos,
#&gt;                                 verbose = verbose)
#&gt;   if (verbose) cat("[parseDataArray] Parsed field descriptions:", toString(.fields), "\n")
#&gt; 
#&gt;   .encParser &lt;- sosParsers(sos)[[sweEncodingName]]
#&gt;   .encodingXml &lt;- xml2::xml_child(x = obj,
#&gt;                                   search = sweEncodingName,
#&gt;                                   ns = SosAllNamespaces())
#&gt;   .encoding &lt;- .encParser(obj = .encodingXml, sos = sos, verbose = verbose)
#&gt; 
#&gt;   if (verbose) cat("[parseDataArray] Parsed encoding description:", toString(.encoding), "\n")
#&gt; 
#&gt;   .valParser &lt;- sosParsers(sos)[[sweValuesName]]
#&gt;   .values &lt;- .valParser(values = xml2::xml_child(x = obj,
#&gt;                                                  search = sweValuesName,
#&gt;                                                  ns = SosAllNamespaces()),
#&gt;                         fields = .fields,
#&gt;                         encoding = .encoding,
#&gt;                         sos = sos, verbose = verbose)
#&gt; 
#&gt;   return(.values)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:elementType`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   elementTypeHref &lt;- stringr::str_remove_all(xml2::xml_attr(x = obj, attr = "href"), "#")
#&gt;   if (verbose) cat("[parseElementType] Got child", xml2::xml_name(xml2::xml_children(obj)),
#&gt;                    "and id", elementTypeHref, "for object", xml2::xml_name(obj), "\n")
#&gt; 
#&gt;   if (is.na(elementTypeHref)) {
#&gt;     elementType &lt;- obj
#&gt;   }
#&gt;   else {
#&gt;     root &lt;- xml2::xml_root(obj)
#&gt;     elementType &lt;- xml2::xml_parent(
#&gt;       xml2::xml_find_first(x = root, xpath = paste0("//*[@gml:id='", elementTypeHref, "']"))
#&gt;     )
#&gt; 
#&gt;     if (is.na(elementType)) {
#&gt;       stop("Got ", sweElementTypeName," with a reference (href) but cannot find definition - cannot parse!",
#&gt;            toString(obj))
#&gt;     } else  {
#&gt;       if (verbose) cat("[parseDataArray] Found elementType via reference", elementTypeHref, "\n")
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   simpleDataRecord &lt;- xml2::xml_child(x = elementType, search = sweSimpleDataRecordName, ns = SosAllNamespaces())
#&gt;   dataRecord &lt;- xml2::xml_child(x = elementType, search = sweDataRecordName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (!is.na(simpleDataRecord) || !is.na(dataRecord)) {
#&gt;     # pick the existing one
#&gt;     if (!is.na(simpleDataRecord)) dr &lt;- simpleDataRecord
#&gt;     else dr &lt;- dataRecord
#&gt; 
#&gt;     fields &lt;- xml2::xml_find_all(x = dr,
#&gt;                                  xpath = sweFieldName,
#&gt;                                  ns = SosAllNamespaces())
#&gt; 
#&gt;     if (verbose) cat("[parseElementType] Got data record with", length(fields), "fields. \n")
#&gt; 
#&gt;     # extract the fields, naming with attribute 'name'
#&gt;     parsedFields &lt;- lapply(fields, parseField, sos = sos, verbose = verbose)
#&gt;     names &lt;- sapply(parsedFields, "[", "name")
#&gt;     names(parsedFields) &lt;- names
#&gt; 
#&gt;     if (verbose) cat("[parseElementType] Names of parsed fields:", names(fields), "\n")
#&gt; 
#&gt;     return(parsedFields)
#&gt;   }
#&gt;   else {
#&gt;     stop(paste("Cannot parse swe:elementType, only children of type",
#&gt;                sweSimpleDataRecordName, "and", sweDataRecordName,
#&gt;                "are supported!"))
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:encoding`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .textBlock &lt;- xml2::xml_child(x = obj, search = sweTextBlockName, ns = SosAllNamespaces())
#&gt; 
#&gt;   .textEncoding &lt;- xml2::xml_child(x = obj, search = sweTextEncodingName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (!(is.na(.textBlock))) {
#&gt;     .tb &lt;- parseTextBlock(.textBlock)
#&gt;     return(.tb)
#&gt;   }
#&gt;   else if (!(is.na(.textEncoding))) {
#&gt;     .tb &lt;- parseTextEncoding(.textEncoding)
#&gt;     return(.tb)
#&gt;   }
#&gt;   else {
#&gt;     stop(paste("Cannot parse swe:encoding, only", sweTextBlockName, "and", sweTextEncodingName,
#&gt;                "are supported!"))
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:values`
#&gt; function(values, fields, encoding, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseValues] Parsing swe:values using", toString(encoding), "and",
#&gt;                   length(fields), "fields:", toString(names(fields)), "\n")
#&gt;   if (!(inherits(encoding, "SweTextBlock") || inherits(encoding, "SweTextEncoding"))) {
#&gt;     stop("Handling for given encoding not implemented!")
#&gt;   }
#&gt; 
#&gt;   .converters &lt;- sosDataFieldConverters(sos)
#&gt; 
#&gt;   .blockLines &lt;- strsplit(x = xml2::xml_text(x = values),
#&gt;                           split = encoding@blockSeparator)
#&gt;   .tokenLines &lt;- sapply(.blockLines, strsplit,
#&gt;                         split = encoding@tokenSeparator)
#&gt; 
#&gt;   if (verbose)
#&gt;     cat("[parseValues] Parsing values from lines: ", toString(.tokenLines), "\n")
#&gt; 
#&gt;   # data frame of correct length to be able to use cbind for first column
#&gt;   .tempId = "tempID"
#&gt;   .data &lt;- data.frame(seq(1,length(.tokenLines)))
#&gt;   names(.data) &lt;- .tempId
#&gt; 
#&gt;   # do following for all fields
#&gt;   .fieldCount &lt;- length(fields)
#&gt;   for (.currentFieldIdx in seq(1,.fieldCount)) {
#&gt;     if (verbose) cat("[parseValues] Processing field index", .currentFieldIdx , "of", .fieldCount,"\n")
#&gt; 
#&gt;     # create list for each variable
#&gt;     .currentValues &lt;- sapply(.tokenLines, "[[", .currentFieldIdx)
#&gt;     if (verbose)
#&gt;       cat("[parseValues] Current values: ", toString(.currentValues), "\n")
#&gt;     .currentField &lt;- fields[[.currentFieldIdx]]
#&gt; 
#&gt;     if (verbose)
#&gt;       cat("[parseValues] Parsing field", paste(.currentField), "\n")
#&gt; 
#&gt;     # convert values to the correct types
#&gt;     .fieldDefinition &lt;- .currentField[["definition"]]
#&gt;     .method &lt;- .converters[[.fieldDefinition]]
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] Using converter:\n")
#&gt;       print(.method)
#&gt;     }
#&gt; 
#&gt;     if (is.null(.method)) {
#&gt;       # could still be a unit of measurement given, use as
#&gt;       if (!is.na(.currentField["uom"])) {
#&gt;         .method &lt;- .converters[[.currentField[["uom"]]]]
#&gt;         if (is.null(.method)) {
#&gt;           # fallback option
#&gt;           warning(paste("No converter for the unit of measurement ",
#&gt;                         .currentField[["uom"]],
#&gt;                         " with the definition ",
#&gt;                         .currentField[["definition"]],
#&gt;                         "! Trying a default, but you can add one when creating a SOS using",
#&gt;                         "SosDataFieldConvertingFunctions().\n"))
#&gt; 
#&gt;           .method &lt;- .converters[["fallBack"]]
#&gt;         }
#&gt;       }
#&gt;       else {
#&gt;         warning(paste("No converter found for the given field", toString(.currentField),
#&gt;                       "using fallBack converter."))
#&gt;         .method &lt;- .converters[["fallBack"]]
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] Using converter function:\n")
#&gt;       show(.method)
#&gt;     }
#&gt; 
#&gt;     # do the conversion
#&gt;     .currentValues &lt;- .method(x = .currentValues, sos = sos)
#&gt; 
#&gt;     # bind new and existing data:
#&gt;     if (verbose) cat("[parseValues] Binding additional data.frame for",
#&gt;                     .currentField[["name"]],
#&gt;                     "-- value range", toString(range(.currentValues)), "\n")
#&gt;     .newData &lt;- data.frame(.currentValues)
#&gt; 
#&gt;     # create the names of the new data:
#&gt;     .newDataName &lt;- .currentField[["name"]]
#&gt;     names(.newData) &lt;- .cleanupColumnName(.newDataName)
#&gt; 
#&gt;     if (verbose) cat("[parseValues] Added column name:", names(.newData), "\n")
#&gt; 
#&gt;     # bind existing and new data column
#&gt;     .data &lt;- cbind(.data, .newData)
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] The new bound data frame (one variable the a temp id):\n")
#&gt;       str(.data)
#&gt;     }
#&gt; 
#&gt;     # add field information as attributes to the new column using human
#&gt;     # readable names
#&gt;     .addAttrs &lt;- as.list(.currentField)
#&gt;     names(.addAttrs) &lt;- .sosParseFieldReadable[names(.currentField)]
#&gt; 
#&gt;     .lastColumn &lt;- dim(.data)[[2]]
#&gt;     .oldAttrs &lt;- attributes(.data[,.lastColumn])
#&gt; 
#&gt;     attributes(.data[,.lastColumn]) &lt;- c(as.list(.oldAttrs), .addAttrs)
#&gt; 
#&gt;     if (verbose) cat("[parseValues] Added attributes to new data:",
#&gt;                     toString(.addAttrs),
#&gt;                     "[ names: ", toString(names(.addAttrs)), "]",
#&gt;                     "\n[parseValues] Old attributes list is",
#&gt;                     toString(.oldAttrs),
#&gt;                     "\n[parseValues] New attributes list is",
#&gt;                     toString(attributes(.data[,.lastColumn])),
#&gt;                     "\n")
#&gt;   }
#&gt; 
#&gt;   # remove id column
#&gt;   if (verbose) cat("[parseValues] Removing temporary first column\n")
#&gt;   .data &lt;- .data[,!colnames(.data) %in% .tempId]
#&gt; 
#&gt;   if (verbose) {
#&gt;     cat("[parseValues] returning final data frame:\n")
#&gt;     str(.data)
#&gt;   }
#&gt;   return(.data)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Position`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .rF &lt;- xml2::xml_attr(x = obj, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;   if (verbose) cat("[parseSwePosition] with referenceFrame", .rF, "\n")
#&gt; 
#&gt;   .location &lt;- xml2::xml_child(x = obj, search = sweLocationName, ns = SosAllNamespaces())
#&gt;   .parser &lt;- sosParsers(sos)[[sweLocationName]]
#&gt; 
#&gt;   .pos &lt;- .parser(.location, sos = sos, verbose = verbose)
#&gt; 
#&gt;   .oldAttrs &lt;- attributes(.pos)
#&gt;   attributes(.pos) &lt;- c(.oldAttrs, list(referenceFrame = .rF))
#&gt; 
#&gt;   return(.pos)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:location`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .vector &lt;- xml2::xml_child(x = obj, search = sweVectorName, ns = SosAllNamespaces())
#&gt;   .id &lt;- xml2::xml_attr(x = obj, attr = "id")
#&gt;   if (verbose) cat("[parseSweLocation] with id", .id, "\n")
#&gt; 
#&gt;   .parser &lt;- sosParsers(sos)[[sweVectorName]]
#&gt;   location &lt;- .parser(.vector, sos = sos, verbose = verbose)
#&gt; 
#&gt;   return(location)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Vector`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .children &lt;- xml2::xml_find_all(x = obj,
#&gt;                                   xpath = sweCoordinateName,
#&gt;                                   ns = SosAllNamespaces())
#&gt; 
#&gt;   .parser &lt;- sosParsers(sos)[[sweCoordinateName]]
#&gt;   .vector &lt;- lapply(X = .children, FUN = .parser, sos = sos, verbose = verbose)
#&gt;   names(.vector) &lt;- sapply(.vector, function(current) {return(current$axisID)})
#&gt;   if (verbose) cat("[parseSweVector] parsed vector with coordinates: ", toString(names(.vector)), "\n")
#&gt; 
#&gt;   return(.vector)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:coordinate`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .name &lt;- xml2::xml_attr(x = obj, attr = "name")
#&gt;   if (verbose) cat("[parseSweCoordinate] with name", .name, "\n")
#&gt; 
#&gt;   .quantity &lt;- xml2::xml_child(x = obj, search = sweQuantityName, ns = SosAllNamespaces())
#&gt;   .axisID &lt;- xml2::xml_attr(x = .quantity, attr = "axisID")
#&gt;   if (verbose) cat("[parseSweCoordinate] axisID: ", .axisID, "\n")
#&gt; 
#&gt;   .uomNode &lt;- xml2::xml_child(x = .quantity, search = sweUomName, ns = SosAllNamespaces())
#&gt;   .uomCode &lt;- xml2::xml_attr(x = .uomNode, attr = "code", ns = SosAllNamespaces())
#&gt;   if (verbose) cat("[parseSweCoordinate] uomCode: ", .uomCode, "\n")
#&gt; 
#&gt;   .valueNode &lt;- xml2::xml_child(x = .quantity, search = sweValueName, ns = SosAllNamespaces())
#&gt;   .value &lt;- as.double(xml2::xml_text(x = .valueNode))
#&gt;   if (verbose) cat("[parseSweCoordinate] value: ", .value, "\n")
#&gt; 
#&gt;   return(list(name = .name,
#&gt;               axisID = .axisID,
#&gt;               uomCode = .uomCode,
#&gt;               value = .value))
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:GeometryObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:GeometryObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CategoryObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:CategoryObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CountObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:CountObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TruthObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:TruthObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TemporalObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:TemporalObservatio is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ComplexObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:ComplexObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/csv`
#&gt; function(obj, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseCSV] Parsing CSV...\n")
#&gt; 
#&gt;   if (inherits(x = obj, what = "data.frame")) {
#&gt;     if (verbose) cat("[parseCSV] Already a data.frame, returning object\n")
#&gt;     return(obj)
#&gt;   }
#&gt; 
#&gt;   .lines &lt;- strsplit(x = obj, split = "\n")[[1]]
#&gt;   .data &lt;- do.call(what = "strsplit", args = list(.lines, split = ","))
#&gt; 
#&gt;   # clean up names (double quotes)
#&gt;   .names &lt;- .data[[1]]
#&gt;   .newNames &lt;- c()
#&gt;   for (.n in .names) {
#&gt;     .newNames &lt;- c(.newNames,
#&gt;                    gsub(pattern = "\"", replacement = "", x = .n))
#&gt;   }
#&gt;   .names &lt;- .newNames
#&gt; 
#&gt;   .rows &lt;- length(.data)
#&gt;   if (verbose) cat("[parseCSV] Got", .rows, "lines of data.\n")
#&gt; 
#&gt;   .df &lt;- NULL
#&gt;   for (.r in seq(2,.rows)) {
#&gt;     if (verbose) cat("[parseCSV] Processing row in CSV:", .data[[.r]], "\n")
#&gt; 
#&gt;     # initialize first column of the data frame so it can be bound in loop
#&gt;     .row.df &lt;- as.data.frame(.data[[.r]][1])
#&gt;     names(.row.df) &lt;- .names[[1]]
#&gt; 
#&gt;     for (i in seq(2,length(.names))) {
#&gt;       .df &lt;- as.data.frame(.data[[.r]][i])
#&gt;       names(.df) &lt;- .names[[i]]
#&gt;       .row.df &lt;- cbind(.row.df, .df)
#&gt;     }
#&gt; 
#&gt;     if (is.null(.df))
#&gt;       .df &lt;- .row.df
#&gt;     else
#&gt;       .df &lt;- do.call(rbind, list(.df, .row.df))
#&gt;   }
#&gt; 
#&gt;   if (verbose) cat("[parseCSV] Done.\n")
#&gt; 
#&gt;   return(.df)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml;subtype="om/1.0.0"`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`application/vnd.google-earth.kml+xml`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseKML] Processing KML... returning raw object!\n")
#&gt; 
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $kml
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseKML] Processing KML... returning raw object!\n")
#&gt; 
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
<span class='co'># use inclusion and exclusion, important: even the just added function needs to</span>
<span class='co'># be included manually!</span>
<span class='fu'>SosParsingFunctions</span>(<span class='st'>"ExceptionReport"</span> <span class='kw'>=</span> <span class='no'>myER</span>,
        <span class='kw'>include</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>, <span class='st'>"ExceptionReport"</span>))</div><div class='output co'>#&gt; $GetObservation
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $DescribeSensor
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseSensorML] Starting... \n")
#&gt; 
#&gt;   .id &lt;- .smlIdentifier(obj, "uniqueID", verbose = verbose)
#&gt;   .shortName &lt;- .smlIdentifier(obj, "shortName", verbose = verbose)
#&gt;   .descrNode &lt;- xml2::xml_find_first(x = obj,
#&gt;                                      xpath = .smlXPathDescription,
#&gt;                                      ns = SosAllNamespaces())
#&gt;   .description &lt;- xml2::xml_text(x = .descrNode)
#&gt; 
#&gt;   if (verbose) cat("[parseSensorML] Got ID", .id,
#&gt;                    "and shortName", .shortName,
#&gt;                    "and description", .description, "\n")
#&gt; 
#&gt;   # bounded by
#&gt;   if (verbose) cat("[parseSensorML] Parsing boundedBy from", .smlXPathObservedBBox, "\n")
#&gt;   .observedBBox &lt;- xml2::xml_find_first(x = obj,
#&gt;                                         xpath = .smlXPathObservedBBox,
#&gt;                                         ns = SosAllNamespaces())
#&gt;   if (!is.na(.observedBBox)) {
#&gt;     .referenceFrame &lt;- xml2::xml_attr(x = .observedBBox, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;     .llVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox,
#&gt;                                              search = paste0(sweUpperCornerName, "/", sweVectorName),
#&gt;                                              ns = SosAllNamespaces()),
#&gt;                              sos = sos, verbose = verbose)
#&gt;     .uuVector &lt;- parseSweVector(xml2::xml_child(x = .observedBBox,
#&gt;                                              search = paste0(sweLowerCornerName, "/", sweVectorName),
#&gt;                                              ns = SosAllNamespaces()),
#&gt;                              sos = sos, verbose = verbose)
#&gt;     .bb &lt;- matrix(c(.llVector[["x"]][["value"]],
#&gt;                     .llVector[["y"]][["value"]],
#&gt;                     .uuVector[["x"]][["value"]],
#&gt;                     .uuVector[["y"]][["value"]]),
#&gt;                   ncol = 2,
#&gt;                   dimnames = list(c("coords.lon", "coords.lat"),
#&gt;                                   c("min", "max")))
#&gt;     .oldAttrs &lt;- attributes(.bb)
#&gt;     attributes(.bb) &lt;- c(.oldAttrs,
#&gt;                          list(referenceFrame = .referenceFrame))
#&gt; 
#&gt;     if (verbose) cat("[parseSensorML] Parsed bounding box: ", toString(.bb), "\n")
#&gt;   }
#&gt;   else {
#&gt;     .bb &lt;- matrix()
#&gt;     if (verbose) cat("[parseSensorML] No boundedBy element found, bbox is ", .bb, "\n")
#&gt;   }
#&gt; 
#&gt;   # coordinates
#&gt;   if (verbose) cat("[parseSensorML] Parsing coordinates from", .smlXPathPosition, "\n")
#&gt;   .xmlPosition &lt;- xml2::xml_find_first(x = obj,
#&gt;                                        xpath = .smlXPathPosition,
#&gt;                                        ns = SosAllNamespaces())
#&gt;   if (!is.na(.xmlPosition)) {
#&gt;     .position &lt;- parseSwePosition(.xmlPosition,
#&gt;                                   sos = sos,
#&gt;                                   verbose = verbose)
#&gt;     .referenceFrame = attributes(.position)[["referenceFrame"]]
#&gt;     .uom &lt;- lapply(.position, "[[", "uomCode")
#&gt;     names(.uom) &lt;- lapply(.position, "[[", "axisID")
#&gt;     .name &lt;- lapply(.position, "[[", "name")
#&gt;     names(.name) &lt;- lapply(.position, "[[", "axisID")
#&gt; 
#&gt;     .values &lt;- lapply(.position, "[[", "value")
#&gt;     names(.values) &lt;- lapply(.position, "[[", "axisID")
#&gt;     if (any(is.na(names(.values)))) {
#&gt;       warning("[parseSensorML] No axisID given, cannot name data.frame with them, trying 'name'.")
#&gt;       names(.values) &lt;- lapply(.position, "[[", "name")
#&gt;     }
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseSensorML] names: ", names(.values), "\n")
#&gt;       cat("[parseSensorML] values: ", toString(.values),	"\n")
#&gt;     }
#&gt; 
#&gt;     .coords &lt;- data.frame(.values)
#&gt;     .oldAttrs &lt;- attributes(.coords)
#&gt;     attributes(.coords) &lt;- c(as.list(.oldAttrs),
#&gt;                              list(referenceFrame = .referenceFrame,
#&gt;                                   uom = .uom, name = .name))
#&gt; 
#&gt;     if (!is.na(.id))
#&gt;       row.names(.coords) &lt;- .id
#&gt;     if (verbose) cat("[parseSensorML]  row names: ", row.names(.coords),
#&gt;                     "\n")
#&gt;   }
#&gt;   else {
#&gt;     .coords &lt;- data.frame()
#&gt;   }
#&gt; 
#&gt;   # create instance
#&gt;   .sml = SensorML(xml = obj,
#&gt;                   coords = .coords,
#&gt;                   id = .id,
#&gt;                   name = .shortName,
#&gt;                   description = .description,
#&gt;                   boundedBy = .bb)
#&gt; 
#&gt;   if (verbose) cat("[parseSensorML]  Done: ", toString(.sml), "\n")
#&gt; 
#&gt;   return(.sml)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $ExceptionReport
#&gt; function(xml) {
#&gt; 	return("EXCEPTION!!!11")
#&gt; }
#&gt; &lt;environment: 0x564ebe6e8000&gt;
#&gt; </div><div class='input'><span class='fu'>SosParsingFunctions</span>(<span class='kw'>exclude</span> <span class='kw'>=</span> <span class='fu'><a href='https://www.rdocumentation.org/packages/base/topics/c'>c</a></span>(<span class='st'>"GetObservation"</span>, <span class='st'>"DescribeSensor"</span>))</div><div class='output co'>#&gt; $GetCapabilities
#&gt; function(obj, sos) {
#&gt;   if (sos@version == sos100_version){
#&gt;     .caps &lt;- parseSosCapabilities100(obj, sos)
#&gt;   }
#&gt;   else if (sos@version == sos200_version){
#&gt;     .caps &lt;- parseSosCapabilities200(obj, sos)
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (sos@verboseOutput) {
#&gt;     cat("[parseGetObservationResponse] entering... \n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   .observationsXML &lt;- xml2::xml_find_all(x = obj,
#&gt;                                          xpath = "sos20:observationData",
#&gt;                                          ns = SosAllNamespaces(version = sos200_version))
#&gt;   featureCache &lt;- list()
#&gt;   .observations &lt;- sapply(.observationsXML,
#&gt;                          parseObservation_2.0,
#&gt;                          sos = sos,
#&gt;                          featureCache = featureCache)
#&gt; 
#&gt;   return(.observations)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetFeatureOfInterestResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt; 
#&gt;   if (sos@verboseOutput) {
#&gt;     cat("[parseGetFeatureOfInterestResponse] entering... \n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   .featureXML &lt;- xml2::xml_find_all(x = obj,
#&gt;                                     xpath = "sos20:featureMember",
#&gt;                                     SosAllNamespaces(version = sos200_version))
#&gt;   .foi = sapply(.featureXML, .parseFeatureMember, sos = sos)
#&gt;   return(.foi)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetObservationById
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`ows:ExceptionReport`
#&gt; function(obj, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseOwsExceptionReport] Starting ...\n")
#&gt;   .docRoot &lt;- xml2::xml_root(x = obj)
#&gt; 
#&gt;   .version &lt;- xml2::xml_attr(x = .docRoot, attr = "version")
#&gt;   .lang &lt;- xml2::xml_attr(x = .docRoot, attr = "lang", default = NA_character_)
#&gt; 
#&gt;   .exceptionsXML &lt;- xml2::xml_find_all(x = .docRoot,
#&gt;                                        xpath = paste0("//", owsExceptionName),
#&gt;                                        ns = SosAllNamespaces())
#&gt; 
#&gt;   .exceptions = sapply(.exceptionsXML, parseOwsException)
#&gt;   if (verbose) cat("[parseOwsExceptionReport]", length(.exceptions), "exceptions.")
#&gt; 
#&gt;   .report &lt;- OwsExceptionReport(version = .version, lang = .lang, exceptions = .exceptions)
#&gt; 
#&gt;   return(.report)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $GetDataAvailabilityResponse
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse]")
#&gt; 
#&gt;   if (sos@version != sos200_version) {
#&gt;     stop(paste0("[parseGetDataAvailabilityResponse] SOS version 2.0 required! Received '",
#&gt;                 sos@version, "'"))
#&gt;   }
#&gt; 
#&gt;   .gdaMembers &lt;- xml2::xml_find_all(x = obj, xpath = sosGDAMemberName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse] with", length(.gdaMembers), "element(s).\n")
#&gt;   phenTimeCache &lt;- list()
#&gt;   .parsedGDAMembers &lt;- lapply(.gdaMembers, .parseGDAMember, sos, phenTimeCache, verbose)
#&gt;   if (verbose) cat("[parseGetDataAvailabilityResponse] Done. Processed", length(.parsedGDAMembers),
#&gt;                    "elements")
#&gt;   return(.parsedGDAMembers)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Measurement`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseMeasurement]\n")
#&gt; 
#&gt;   .samplingTimeXml &lt;- xml2::xml_child(x = obj,
#&gt;                                       search = omSamplingTimeName,
#&gt;                                       ns = SosAllNamespaces())
#&gt;   .samplingTime &lt;- parseTime(obj = .samplingTimeXml,
#&gt;                              format = sosTimeFormat(sos),
#&gt;                              verbose = verbose)
#&gt; 
#&gt;   # 52N SOS only returns om:Measurements (!) with procedure ids and observed
#&gt;   # properties in xlink:href
#&gt;   .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj, search = omProcedureName, ns = SosAllNamespaces()), attr = "href")
#&gt;   .observedProperty &lt;- SwePhenomenonProperty(
#&gt;     href = xml2::xml_attr(x = xml2::xml_child(x = obj, search = omObservedPropertyName, ns = SosAllNamespaces()), attr = "href"))
#&gt; 
#&gt;   .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()), sos = sos,
#&gt;                                  verbose = verbose)
#&gt; 
#&gt;   # must be GmlMeasure
#&gt;   .result &lt;- parseMeasure(xml2::xml_child(x = obj, search = omResultName, ns = SosAllNamespaces()))
#&gt; 
#&gt;   # TODO optionals elements for OmMeasurement
#&gt;   #.metadata
#&gt;   #.resultTime
#&gt;   #.resultQuality
#&gt;   #.parameter
#&gt; 
#&gt;   .measurement &lt;- OmMeasurement(samplingTime = .samplingTime,
#&gt;                                 procedure = .procedure, observedProperty = .observedProperty,
#&gt;                                 featureOfInterest = .featureOfInterest, result = .result)
#&gt; 
#&gt;   return(.measurement)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:member`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   # a member can only have one child element
#&gt;   if (xml2::xml_length(x = obj) &gt;= 1) {
#&gt;     .child &lt;- xml2::xml_child(obj)
#&gt;     if (verbose) cat("[parseObservationProperty] Parsing child of member:",
#&gt;                      xml2::xml_name(x = .child, ns = SosAllNamespaces()), "\n")
#&gt;     .mResult &lt;- parseOM(.child, sos, verbose)
#&gt;   }
#&gt;   else {
#&gt;     # no child, try href attribute
#&gt;     if (verbose) cat("[parseObservationProperty] Member has no direct child!\n")
#&gt; 
#&gt;     .href &lt;- xml2::xml_attr(x = obj, attr = "href", default = NA_character_)
#&gt;     if (!is.na(.href)) {
#&gt;       warning("Only reference was returned:", .href)
#&gt;       .mResult &lt;- OmObservationProperty(href = .href)
#&gt;     }
#&gt;     else {
#&gt;       warning("No observation found!")
#&gt;       .mResult &lt;- OmObservationProperty()
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   return(.mResult)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:Observation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .id &lt;- xml2::xml_attr(x = obj, attr = "id", default = NA_character_)
#&gt;   if (verbose) cat("[parseObservation]", .id, "\n")
#&gt; 
#&gt;   # 52N SOS only returns om:Observation with procedure ids xlink:href
#&gt;   .procedure &lt;- xml2::xml_attr(x = xml2::xml_child(x = obj,
#&gt;                                                    search = omProcedureName,
#&gt;                                                    ns = SosAllNamespaces()),
#&gt;                                attr = "href",
#&gt;                                default = NA_character_)
#&gt; 
#&gt;   .observedProperty &lt;- parsePhenomenonProperty(xml2::xml_child(x = obj, search = omObservedPropertyName, ns = SosAllNamespaces()),
#&gt;                                                verbose = verbose)
#&gt; 
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omSamplingTimeName, ns = SosAllNamespaces()))) {
#&gt;     .samplingTime &lt;- parseTime(obj = xml2::xml_child(x = obj,
#&gt;                                                      search = omSamplingTimeName,
#&gt;                                                      ns = SosAllNamespaces()),
#&gt;                                format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;   } else {
#&gt;     warning("om:samplingTime is mandatory in om:Observation, but is missing!")
#&gt;     .samplingTime &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()))) {
#&gt;     .featureOfInterest &lt;- parseFOI(xml2::xml_child(x = obj, search = omFeatureOfInterestName, ns = SosAllNamespaces()),
#&gt;                                    sos = sos, verbose = verbose)
#&gt;   } else {
#&gt;     warning("om:featureOfInterest is mandatory in om:Observation, but is missing!")
#&gt;     .featureOfInterest &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   # result parser is exchangeable
#&gt;   .resultParsingFunction &lt;- sosParsers(sos)[[omResultName]]
#&gt;   .result &lt;- .resultParsingFunction(xml2::xml_child(x = obj, search = omResultName, ns = SosAllNamespaces()), sos, verbose)
#&gt; 
#&gt;   # optional elements
#&gt;   if (!is.na(xml2::xml_child(x = obj, search = omResultTimeName, ns = SosAllNamespaces()))) {
#&gt;     .resultTime &lt;- parseTime(obj = xml2::xml_child(x = obj, search = omResultTimeName, ns = SosAllNamespaces()),
#&gt;                              format = sosTimeFormat(sos = sos), verbose = verbose)
#&gt;   }
#&gt;   else {
#&gt;     .resultTime &lt;- NULL
#&gt;   }
#&gt; 
#&gt;   # TODO optionals elements for OmObservation
#&gt;   #.metadata
#&gt;   #.resultQuality
#&gt;   #.parameter
#&gt;   #.metadata
#&gt; 
#&gt;   .obs &lt;- OmObservation(samplingTime = .samplingTime,
#&gt;                         procedure = .procedure,
#&gt;                         observedProperty = .observedProperty,
#&gt;                         featureOfInterest = .featureOfInterest,
#&gt;                         result = .result)
#&gt; 
#&gt;   return(.obs)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ObservationCollection`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .members &lt;- xml2::xml_find_all(x = obj, xpath = omMemberName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (verbose) cat("[parseObservationCollection] with ", length(.members), "element(s).\n")
#&gt; 
#&gt;   .env &lt;- xml2::xml_child(x = obj, search = paste0(gmlBoundedByName, "/", gmlEnvelopeName))
#&gt;   if (!is.na(.env)) {
#&gt;     .boundedBy &lt;- list(
#&gt;       srsName = xml2::xml_attr(x = .env, attr = "srsName", ns = SosAllNamespaces()),
#&gt;       lowerCorner = xml2::xml_text(x = xml2::xml_child(x = .env, search = gmlLowerCornerName, ns = SosAllNamespaces())),
#&gt;       upperCorner = xml2::xml_text(x = xml2::xml_child(x = .env, search = gmlUpperCornerName, ns = SosAllNamespaces())))
#&gt; 
#&gt;     if (verbose) cat("[parseObservationCollection] Parsed envelope:", toString(.boundedBy), "\n")
#&gt; 
#&gt;     if (sosSwitchCoordinates(sos)) {
#&gt;       warning("Switching coordinates in envelope of ObservationCollection!")
#&gt;       .origLC &lt;- strsplit(x = .boundedBy[["lowerCorner"]], split = " ")
#&gt;       .lC &lt;- paste(.origLC[[1]][[2]], .origLC[[1]][[1]])
#&gt;       .origUC &lt;- strsplit(x = .boundedBy[["upperCorner"]], split = " ")
#&gt;       .uC &lt;- paste(.origUC[[1]][[2]], .origUC[[1]][[1]])
#&gt;       .boundedBy &lt;- list(srsName = xml2::xml_attr(x = .env, attr = "srsName"),
#&gt;                          lowerCorner = .lC, upperCorner = .uC)
#&gt;     }
#&gt;   }
#&gt;   else {
#&gt;     if (verbose) cat("[parseObservationCollection] Empty envelope!\n")
#&gt;     .boundedBy &lt;- list()
#&gt;   }
#&gt; 
#&gt;   .resultList &lt;- lapply(X = .members, FUN = parseOM, sos = sos, verbose = verbose)
#&gt;   names(.resultList) &lt;- lapply(X = .members, FUN = function(member) {
#&gt;     children &lt;- xml2::xml_children(member)
#&gt;     idOrName &lt;- xml2::xml_attr(children, attr = "id", default = xml2::xml_name(children))
#&gt;     if (length(idOrName) &lt; 1) {
#&gt;       xml2::xml_name(member)
#&gt;     } else {
#&gt;       idOrName
#&gt;     }
#&gt;   })
#&gt; 
#&gt;   if (is.list(.resultList)) {
#&gt;     .obsColl &lt;- OmObservationCollection(members = .resultList,
#&gt;                                         boundedBy = .boundedBy)
#&gt;   }
#&gt;   else {
#&gt;     .obsColl &lt;- OmObservationCollection(members = list(.resultList),
#&gt;                                         boundedBy = .boundedBy)
#&gt;   }
#&gt; 
#&gt;   if (verbose)
#&gt;     cat("[parseObservationCollection] Done. Processed", length(.obsColl),
#&gt;         "elements:", names(.obsColl), "\n")
#&gt; 
#&gt;   return(.obsColl)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:result`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseResult] Starting ...\n")
#&gt;   .result &lt;- NULL
#&gt; 
#&gt;   .children &lt;- xml2::xml_children(x = obj)
#&gt;   if (verbose) cat("[parseResult]", length(.children), " non-text nodes, names:", xml2::xml_name(.children), "\n")
#&gt; 
#&gt;   # Check if remaining element is there
#&gt;   if (length(.children) == 0) {
#&gt;     .children &lt;- xml2::xml_children(x = obj)
#&gt;     stop("Continue implementation here: OM-methods-parsing.R")
#&gt;     cat("[parseResult] No non-text nodes in result, returning NULL.\n")
#&gt; 
#&gt;     #in O&amp;M 2.0 there can be (literal) results of type MeasurementType
#&gt;     .typeAttributValue &lt;- xml2::xml_attr(x = obj, attr = om20ResultTypeAttributeName, default = NA_character_)
#&gt; 
#&gt;     .typeWithQualifiedname &lt;- strsplit(.typeAttributValue, ":")
#&gt; 
#&gt;     .type &lt;- NA_character_
#&gt; 
#&gt;     if (length(.typeWithQualifiedname) &gt; 0) {
#&gt; 
#&gt;       if (length(.typeWithQualifiedname[[1]]) &gt; 1) {
#&gt;         .type &lt;- .typeWithQualifiedname[[1]][2]
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     if (!is.na(.type)) {
#&gt;       if (.type == om20ResultMeasureTypeName) {
#&gt;         return(xml2::xml_text(x = obj))
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     return(NULL)
#&gt;   }
#&gt; 
#&gt;   .name &lt;- xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces())
#&gt;   if (.name == sweDataArrayName) {
#&gt;     if (verbose) cat("[parseResult] Parsing result with swe:DataArray.\n")
#&gt; 
#&gt;     # data array parser is exchangeable
#&gt;     .dataArrayParsingFunction &lt;- sosParsers(sos)[[sweDataArrayName]]
#&gt;     .result &lt;- .dataArrayParsingFunction(.children[[1]], sos, verbose)
#&gt;   }
#&gt;   else if (.name == xmlTextNodeName) {
#&gt;     .result &lt;- as.numeric(xml2::xml_text(x = .children))
#&gt;     if (is.na(.result)) {
#&gt;       .result &lt;- xml2::xml_text(x = .children, trim = TRUE)
#&gt;     }
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseResult] Parsing of given result is NOT supported:",
#&gt;                   xml2::xml_name(x = .children[[1]], ns = SosAllNamespaces()),
#&gt;                   "-- only", sweDataArrayName,
#&gt;                   " or text nodes containing strings or numbers can be parsed."))
#&gt;   }
#&gt; 
#&gt;   if (is.null(.result)) {
#&gt;     stop("[parseResult] result is null! Given result:\n")
#&gt;     print(obj)
#&gt;   }
#&gt; 
#&gt;   if (verbose) cat("[parseResult] Done\n")
#&gt; 
#&gt;   return(.result)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:DataArray`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .elementCount &lt;- xml2::xml_text(xml2::xml_find_first(x = obj,
#&gt;                                                        xpath = "./swe:elementCount/swe:Count/swe:value",
#&gt;                                                        ns = SosAllNamespaces())
#&gt;                                   )
#&gt;   if (verbose) cat("[parseDataArray] Parsing DataArray with", .elementCount, "elements.\n")
#&gt; 
#&gt;   .elementTypeParser &lt;- sosParsers(sos)[[sweElementTypeName]]
#&gt;   .elementTypeXml &lt;- xml2::xml_child(x = obj, search = sweElementTypeName, ns = SosAllNamespaces())
#&gt;   .fields &lt;- .elementTypeParser(obj = .elementTypeXml,
#&gt;                                 sos = sos,
#&gt;                                 verbose = verbose)
#&gt;   if (verbose) cat("[parseDataArray] Parsed field descriptions:", toString(.fields), "\n")
#&gt; 
#&gt;   .encParser &lt;- sosParsers(sos)[[sweEncodingName]]
#&gt;   .encodingXml &lt;- xml2::xml_child(x = obj,
#&gt;                                   search = sweEncodingName,
#&gt;                                   ns = SosAllNamespaces())
#&gt;   .encoding &lt;- .encParser(obj = .encodingXml, sos = sos, verbose = verbose)
#&gt; 
#&gt;   if (verbose) cat("[parseDataArray] Parsed encoding description:", toString(.encoding), "\n")
#&gt; 
#&gt;   .valParser &lt;- sosParsers(sos)[[sweValuesName]]
#&gt;   .values &lt;- .valParser(values = xml2::xml_child(x = obj,
#&gt;                                                  search = sweValuesName,
#&gt;                                                  ns = SosAllNamespaces()),
#&gt;                         fields = .fields,
#&gt;                         encoding = .encoding,
#&gt;                         sos = sos, verbose = verbose)
#&gt; 
#&gt;   return(.values)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:elementType`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   elementTypeHref &lt;- stringr::str_remove_all(xml2::xml_attr(x = obj, attr = "href"), "#")
#&gt;   if (verbose) cat("[parseElementType] Got child", xml2::xml_name(xml2::xml_children(obj)),
#&gt;                    "and id", elementTypeHref, "for object", xml2::xml_name(obj), "\n")
#&gt; 
#&gt;   if (is.na(elementTypeHref)) {
#&gt;     elementType &lt;- obj
#&gt;   }
#&gt;   else {
#&gt;     root &lt;- xml2::xml_root(obj)
#&gt;     elementType &lt;- xml2::xml_parent(
#&gt;       xml2::xml_find_first(x = root, xpath = paste0("//*[@gml:id='", elementTypeHref, "']"))
#&gt;     )
#&gt; 
#&gt;     if (is.na(elementType)) {
#&gt;       stop("Got ", sweElementTypeName," with a reference (href) but cannot find definition - cannot parse!",
#&gt;            toString(obj))
#&gt;     } else  {
#&gt;       if (verbose) cat("[parseDataArray] Found elementType via reference", elementTypeHref, "\n")
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   simpleDataRecord &lt;- xml2::xml_child(x = elementType, search = sweSimpleDataRecordName, ns = SosAllNamespaces())
#&gt;   dataRecord &lt;- xml2::xml_child(x = elementType, search = sweDataRecordName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (!is.na(simpleDataRecord) || !is.na(dataRecord)) {
#&gt;     # pick the existing one
#&gt;     if (!is.na(simpleDataRecord)) dr &lt;- simpleDataRecord
#&gt;     else dr &lt;- dataRecord
#&gt; 
#&gt;     fields &lt;- xml2::xml_find_all(x = dr,
#&gt;                                  xpath = sweFieldName,
#&gt;                                  ns = SosAllNamespaces())
#&gt; 
#&gt;     if (verbose) cat("[parseElementType] Got data record with", length(fields), "fields. \n")
#&gt; 
#&gt;     # extract the fields, naming with attribute 'name'
#&gt;     parsedFields &lt;- lapply(fields, parseField, sos = sos, verbose = verbose)
#&gt;     names &lt;- sapply(parsedFields, "[", "name")
#&gt;     names(parsedFields) &lt;- names
#&gt; 
#&gt;     if (verbose) cat("[parseElementType] Names of parsed fields:", names(fields), "\n")
#&gt; 
#&gt;     return(parsedFields)
#&gt;   }
#&gt;   else {
#&gt;     stop(paste("Cannot parse swe:elementType, only children of type",
#&gt;                sweSimpleDataRecordName, "and", sweDataRecordName,
#&gt;                "are supported!"))
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:encoding`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .textBlock &lt;- xml2::xml_child(x = obj, search = sweTextBlockName, ns = SosAllNamespaces())
#&gt; 
#&gt;   .textEncoding &lt;- xml2::xml_child(x = obj, search = sweTextEncodingName, ns = SosAllNamespaces())
#&gt; 
#&gt;   if (!(is.na(.textBlock))) {
#&gt;     .tb &lt;- parseTextBlock(.textBlock)
#&gt;     return(.tb)
#&gt;   }
#&gt;   else if (!(is.na(.textEncoding))) {
#&gt;     .tb &lt;- parseTextEncoding(.textEncoding)
#&gt;     return(.tb)
#&gt;   }
#&gt;   else {
#&gt;     stop(paste("Cannot parse swe:encoding, only", sweTextBlockName, "and", sweTextEncodingName,
#&gt;                "are supported!"))
#&gt;   }
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:values`
#&gt; function(values, fields, encoding, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseValues] Parsing swe:values using", toString(encoding), "and",
#&gt;                   length(fields), "fields:", toString(names(fields)), "\n")
#&gt;   if (!(inherits(encoding, "SweTextBlock") || inherits(encoding, "SweTextEncoding"))) {
#&gt;     stop("Handling for given encoding not implemented!")
#&gt;   }
#&gt; 
#&gt;   .converters &lt;- sosDataFieldConverters(sos)
#&gt; 
#&gt;   .blockLines &lt;- strsplit(x = xml2::xml_text(x = values),
#&gt;                           split = encoding@blockSeparator)
#&gt;   .tokenLines &lt;- sapply(.blockLines, strsplit,
#&gt;                         split = encoding@tokenSeparator)
#&gt; 
#&gt;   if (verbose)
#&gt;     cat("[parseValues] Parsing values from lines: ", toString(.tokenLines), "\n")
#&gt; 
#&gt;   # data frame of correct length to be able to use cbind for first column
#&gt;   .tempId = "tempID"
#&gt;   .data &lt;- data.frame(seq(1,length(.tokenLines)))
#&gt;   names(.data) &lt;- .tempId
#&gt; 
#&gt;   # do following for all fields
#&gt;   .fieldCount &lt;- length(fields)
#&gt;   for (.currentFieldIdx in seq(1,.fieldCount)) {
#&gt;     if (verbose) cat("[parseValues] Processing field index", .currentFieldIdx , "of", .fieldCount,"\n")
#&gt; 
#&gt;     # create list for each variable
#&gt;     .currentValues &lt;- sapply(.tokenLines, "[[", .currentFieldIdx)
#&gt;     if (verbose)
#&gt;       cat("[parseValues] Current values: ", toString(.currentValues), "\n")
#&gt;     .currentField &lt;- fields[[.currentFieldIdx]]
#&gt; 
#&gt;     if (verbose)
#&gt;       cat("[parseValues] Parsing field", paste(.currentField), "\n")
#&gt; 
#&gt;     # convert values to the correct types
#&gt;     .fieldDefinition &lt;- .currentField[["definition"]]
#&gt;     .method &lt;- .converters[[.fieldDefinition]]
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] Using converter:\n")
#&gt;       print(.method)
#&gt;     }
#&gt; 
#&gt;     if (is.null(.method)) {
#&gt;       # could still be a unit of measurement given, use as
#&gt;       if (!is.na(.currentField["uom"])) {
#&gt;         .method &lt;- .converters[[.currentField[["uom"]]]]
#&gt;         if (is.null(.method)) {
#&gt;           # fallback option
#&gt;           warning(paste("No converter for the unit of measurement ",
#&gt;                         .currentField[["uom"]],
#&gt;                         " with the definition ",
#&gt;                         .currentField[["definition"]],
#&gt;                         "! Trying a default, but you can add one when creating a SOS using",
#&gt;                         "SosDataFieldConvertingFunctions().\n"))
#&gt; 
#&gt;           .method &lt;- .converters[["fallBack"]]
#&gt;         }
#&gt;       }
#&gt;       else {
#&gt;         warning(paste("No converter found for the given field", toString(.currentField),
#&gt;                       "using fallBack converter."))
#&gt;         .method &lt;- .converters[["fallBack"]]
#&gt;       }
#&gt;     }
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] Using converter function:\n")
#&gt;       show(.method)
#&gt;     }
#&gt; 
#&gt;     # do the conversion
#&gt;     .currentValues &lt;- .method(x = .currentValues, sos = sos)
#&gt; 
#&gt;     # bind new and existing data:
#&gt;     if (verbose) cat("[parseValues] Binding additional data.frame for",
#&gt;                     .currentField[["name"]],
#&gt;                     "-- value range", toString(range(.currentValues)), "\n")
#&gt;     .newData &lt;- data.frame(.currentValues)
#&gt; 
#&gt;     # create the names of the new data:
#&gt;     .newDataName &lt;- .currentField[["name"]]
#&gt;     names(.newData) &lt;- .cleanupColumnName(.newDataName)
#&gt; 
#&gt;     if (verbose) cat("[parseValues] Added column name:", names(.newData), "\n")
#&gt; 
#&gt;     # bind existing and new data column
#&gt;     .data &lt;- cbind(.data, .newData)
#&gt; 
#&gt;     if (verbose) {
#&gt;       cat("[parseValues] The new bound data frame (one variable the a temp id):\n")
#&gt;       str(.data)
#&gt;     }
#&gt; 
#&gt;     # add field information as attributes to the new column using human
#&gt;     # readable names
#&gt;     .addAttrs &lt;- as.list(.currentField)
#&gt;     names(.addAttrs) &lt;- .sosParseFieldReadable[names(.currentField)]
#&gt; 
#&gt;     .lastColumn &lt;- dim(.data)[[2]]
#&gt;     .oldAttrs &lt;- attributes(.data[,.lastColumn])
#&gt; 
#&gt;     attributes(.data[,.lastColumn]) &lt;- c(as.list(.oldAttrs), .addAttrs)
#&gt; 
#&gt;     if (verbose) cat("[parseValues] Added attributes to new data:",
#&gt;                     toString(.addAttrs),
#&gt;                     "[ names: ", toString(names(.addAttrs)), "]",
#&gt;                     "\n[parseValues] Old attributes list is",
#&gt;                     toString(.oldAttrs),
#&gt;                     "\n[parseValues] New attributes list is",
#&gt;                     toString(attributes(.data[,.lastColumn])),
#&gt;                     "\n")
#&gt;   }
#&gt; 
#&gt;   # remove id column
#&gt;   if (verbose) cat("[parseValues] Removing temporary first column\n")
#&gt;   .data &lt;- .data[,!colnames(.data) %in% .tempId]
#&gt; 
#&gt;   if (verbose) {
#&gt;     cat("[parseValues] returning final data frame:\n")
#&gt;     str(.data)
#&gt;   }
#&gt;   return(.data)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Position`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .rF &lt;- xml2::xml_attr(x = obj, attr = "referenceFrame", ns = SosAllNamespaces())
#&gt;   if (verbose) cat("[parseSwePosition] with referenceFrame", .rF, "\n")
#&gt; 
#&gt;   .location &lt;- xml2::xml_child(x = obj, search = sweLocationName, ns = SosAllNamespaces())
#&gt;   .parser &lt;- sosParsers(sos)[[sweLocationName]]
#&gt; 
#&gt;   .pos &lt;- .parser(.location, sos = sos, verbose = verbose)
#&gt; 
#&gt;   .oldAttrs &lt;- attributes(.pos)
#&gt;   attributes(.pos) &lt;- c(.oldAttrs, list(referenceFrame = .rF))
#&gt; 
#&gt;   return(.pos)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:location`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .vector &lt;- xml2::xml_child(x = obj, search = sweVectorName, ns = SosAllNamespaces())
#&gt;   .id &lt;- xml2::xml_attr(x = obj, attr = "id")
#&gt;   if (verbose) cat("[parseSweLocation] with id", .id, "\n")
#&gt; 
#&gt;   .parser &lt;- sosParsers(sos)[[sweVectorName]]
#&gt;   location &lt;- .parser(.vector, sos = sos, verbose = verbose)
#&gt; 
#&gt;   return(location)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:Vector`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .children &lt;- xml2::xml_find_all(x = obj,
#&gt;                                   xpath = sweCoordinateName,
#&gt;                                   ns = SosAllNamespaces())
#&gt; 
#&gt;   .parser &lt;- sosParsers(sos)[[sweCoordinateName]]
#&gt;   .vector &lt;- lapply(X = .children, FUN = .parser, sos = sos, verbose = verbose)
#&gt;   names(.vector) &lt;- sapply(.vector, function(current) {return(current$axisID)})
#&gt;   if (verbose) cat("[parseSweVector] parsed vector with coordinates: ", toString(names(.vector)), "\n")
#&gt; 
#&gt;   return(.vector)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`swe:coordinate`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .name &lt;- xml2::xml_attr(x = obj, attr = "name")
#&gt;   if (verbose) cat("[parseSweCoordinate] with name", .name, "\n")
#&gt; 
#&gt;   .quantity &lt;- xml2::xml_child(x = obj, search = sweQuantityName, ns = SosAllNamespaces())
#&gt;   .axisID &lt;- xml2::xml_attr(x = .quantity, attr = "axisID")
#&gt;   if (verbose) cat("[parseSweCoordinate] axisID: ", .axisID, "\n")
#&gt; 
#&gt;   .uomNode &lt;- xml2::xml_child(x = .quantity, search = sweUomName, ns = SosAllNamespaces())
#&gt;   .uomCode &lt;- xml2::xml_attr(x = .uomNode, attr = "code", ns = SosAllNamespaces())
#&gt;   if (verbose) cat("[parseSweCoordinate] uomCode: ", .uomCode, "\n")
#&gt; 
#&gt;   .valueNode &lt;- xml2::xml_child(x = .quantity, search = sweValueName, ns = SosAllNamespaces())
#&gt;   .value &lt;- as.double(xml2::xml_text(x = .valueNode))
#&gt;   if (verbose) cat("[parseSweCoordinate] value: ", .value, "\n")
#&gt; 
#&gt;   return(list(name = .name,
#&gt;               axisID = .axisID,
#&gt;               uomCode = .uomCode,
#&gt;               value = .value))
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:GeometryObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:GeometryObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CategoryObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:CategoryObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:CountObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:CountObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TruthObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:TruthObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:TemporalObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:TemporalObservatio is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`om:ComplexObservation`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   warning("Parsing of om:ComplexObservation is not implemented!")
#&gt;   return(NA)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/csv`
#&gt; function(obj, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseCSV] Parsing CSV...\n")
#&gt; 
#&gt;   if (inherits(x = obj, what = "data.frame")) {
#&gt;     if (verbose) cat("[parseCSV] Already a data.frame, returning object\n")
#&gt;     return(obj)
#&gt;   }
#&gt; 
#&gt;   .lines &lt;- strsplit(x = obj, split = "\n")[[1]]
#&gt;   .data &lt;- do.call(what = "strsplit", args = list(.lines, split = ","))
#&gt; 
#&gt;   # clean up names (double quotes)
#&gt;   .names &lt;- .data[[1]]
#&gt;   .newNames &lt;- c()
#&gt;   for (.n in .names) {
#&gt;     .newNames &lt;- c(.newNames,
#&gt;                    gsub(pattern = "\"", replacement = "", x = .n))
#&gt;   }
#&gt;   .names &lt;- .newNames
#&gt; 
#&gt;   .rows &lt;- length(.data)
#&gt;   if (verbose) cat("[parseCSV] Got", .rows, "lines of data.\n")
#&gt; 
#&gt;   .df &lt;- NULL
#&gt;   for (.r in seq(2,.rows)) {
#&gt;     if (verbose) cat("[parseCSV] Processing row in CSV:", .data[[.r]], "\n")
#&gt; 
#&gt;     # initialize first column of the data frame so it can be bound in loop
#&gt;     .row.df &lt;- as.data.frame(.data[[.r]][1])
#&gt;     names(.row.df) &lt;- .names[[1]]
#&gt; 
#&gt;     for (i in seq(2,length(.names))) {
#&gt;       .df &lt;- as.data.frame(.data[[.r]][i])
#&gt;       names(.df) &lt;- .names[[i]]
#&gt;       .row.df &lt;- cbind(.row.df, .df)
#&gt;     }
#&gt; 
#&gt;     if (is.null(.df))
#&gt;       .df &lt;- .row.df
#&gt;     else
#&gt;       .df &lt;- do.call(rbind, list(.df, .row.df))
#&gt;   }
#&gt; 
#&gt;   if (verbose) cat("[parseCSV] Done.\n")
#&gt; 
#&gt;   return(.df)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml;subtype="om/1.0.0"`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`application/vnd.google-earth.kml+xml`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseKML] Processing KML... returning raw object!\n")
#&gt; 
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $kml
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   if (verbose) cat("[parseKML] Processing KML... returning raw object!\n")
#&gt; 
#&gt;   return(obj)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; 
#&gt; $`text/xml`
#&gt; function(obj, sos, verbose = FALSE) {
#&gt;   .om &lt;- NULL
#&gt; 
#&gt;   # switch submethods based on name (needs prefix)
#&gt;   .name &lt;- xml2::xml_name(x = obj, ns = SosAllNamespaces())
#&gt; 
#&gt;   .parsingFunction &lt;- sosParsers(sos)[[.name]]
#&gt;   if (!is.null(.parsingFunction)) {
#&gt;     if (verbose) cat("[parseOM] Matched name for parser is", .name, "\n")
#&gt;     .om &lt;- .parsingFunction(obj = obj, sos = sos, verbose = verbose)
#&gt;     if (verbose) cat("[parseOM] Done parsing\n")
#&gt;   }
#&gt;   else {
#&gt;     warning(paste("[parseOM] No parsing function for given element", .name))
#&gt;   }
#&gt; 
#&gt;   return(.om)
#&gt; }
#&gt; &lt;environment: namespace:sos4R&gt;
#&gt; </div><div class='input'>
</div># NOT RUN {
>>>>>>> dev
# Replace an encoding function
myEncoding <- function(object, v) {
	return(utils::str(object))
}

sos = SOS(url = "http://mysos.com/sos",
		encoders = SosEncodingFunctions("POST" = myPostEncoding))

# Use custom converting function and connection method. This mechanism works the
# same for encoders and decoders.
myConverters <- SosDataFieldConvertingFunctions(
	"myNumericUnit" = sosConvertDouble,
mySos <- SOS(sos.url, binding = "KVP", dataFieldConverters = myConverters)
sosDataFieldConverters(mySos)

# inspecting XML using dummy parsing function
sos = SOS(url = "http://mysos.com/sos", parsers = SosDisabledParsers)
describeSensor(sos, sosProcedures(sos)[[1]])

# replace the parsing functions with the default ones
sos <- SosResetParsingFunctions(sos)
# }
<div class='input'>
</div><span class='co'># NOT RUN {</span>
<span class='co'># a named list of all defaults</span>
<span class='fu'>SosDefaults</span>()
<span class='co'># }</span><div class='input'>
<span class='co'># parsing options used by xml2</span>
<span class='fu'>SosDefaultParsingOptions</span>()</div><div class='output co'>#&gt; [1] "RECOVER"</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#value">Value</a></li>

      <li><a href="#references">References</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Daniel Nuest.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
   </div>

  

  </body>
</html>

