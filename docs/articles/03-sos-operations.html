<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>sos4R: SOS Operations • sos4R</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="sos4R: SOS Operations">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">sos4R</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.3.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/01-quickstart.html">sos4R: Accessing Sensor Observation Services from R -- Quickstart</a>
    </li>
    <li>
      <a href="../articles/02-ogc-sos.html">sos4R: OGC SWE and SOS</a>
    </li>
    <li>
      <a href="../articles/03-sos-operations.html">sos4R: SOS Operations</a>
    </li>
    <li>
      <a href="../articles/04-extensions.html">sos4R: Extending package functions and advanced configuration</a>
    </li>
  </ul>
</li>
<li>
  <a href="../DEV-README.html">Developer Docs</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/52North/sos4R">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>sos4R: SOS Operations</h1>
                        <h4 class="author">Daniel Nüst</h4>
            <address class="author_afil">
      Institute for Geoinformatics, University of Münster, Germany.<br><a class="author_email" href="mailto:#"></a><a href="mailto:daniel.nuest@uni-muenster.de">daniel.nuest@uni-muenster.de</a>
      </address>
                  
            <h4 class="date">2019-01-03</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/52North/sos4R/blob/master/vignettes/03-sos-operations.Rmd"><code>vignettes/03-sos-operations.Rmd</code></a></small>
      <div class="hidden name"><code>03-sos-operations.Rmd</code></div>

    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>The sos4R package provides simple yet powerful access to OGC Sensor Observation Service instances. The package supports both encapsulation and abstraction from the service interface for novice users as well as powerful request building for specialists. sos4R is motivated by the idea to close the gap between the Sensor Web and tools for (geo-)statistical analyses. It implements the core profile of the SOS specification and supports temporal, spatial, and thematical filtering of observations.</p>
      <p>This document describes which of the possible features and implementations of the rather generic standards are supported. It gives a detailed overview of the SOS operations and how to use them with <code>sos4R</code>.</p>
      The package is published under GPL 2 license within the geostatistics community of 52°North Initiative for Geospatial Open Source Software.
    </div>
    

<p>The package provides accessor functions for the supported parameters. It is recommended to access options from the lists returned by these functions instead of hard-coding them into scripts.</p>
<p>This section only lists the possibilities. Explanations follow in this document or can be found in the SOS specification.</p>
<p>&lt;&lt;supported01,echo=TRUE&gt;&gt;= SosSupportedOperations() SosSupportedServiceVersions() SosSupportedBindings() SosSupportedResponseFormats() @</p>
<p>The response format  is not standard conform, but used by services as a well established alternative to XML encodings.</p>
<p>&lt;&lt;supported02,echo=TRUE&gt;&gt;= SosSupportedResponseModes() SosSupportedResultModels() @</p>
<p>The output of the following calls are named lists (the name being the same as the value) which are simplified here for brevity using <code><a href="https://www.rdocumentation.org/packages/base/topics/toString">toString()</a></code>.</p>
<p>&lt;&lt;supported03,echo=TRUE,eval=FALSE&gt;&gt;= SosSupportedSpatialOperators() @ &lt;&lt;supported04,echo=FALSE,eval=TRUE&gt;&gt;= toString(SosSupportedSpatialOperators()) @</p>
<p>&lt;&lt;supported05,echo=TRUE,eval=FALSE&gt;&gt;= SosSupportedTemporalOperators() @ &lt;&lt;supported06,echo=FALSE,eval=TRUE&gt;&gt;= toString(SosSupportedTemporalOperators()) @</p>

<p>Two kinds of default values can be found in (function calls in) : (i) default depending on other function parameters, and (ii) global defaults. Global defaults can be inspected (not changed!) using the following functions. If you want to use a different value please change the respective argument in function calls.</p>
<p>&lt;&lt;default,echo=TRUE&gt;&gt;= SosDefaultBinding() SosDefaults() @</p>
<p>The process of data download also comprises (i) building requests, (ii) decoding responses, and (iii) applying the correct R data type to the respective data values. This mechanism is explained in detail in see section . The package comes with a set of predefined encoders, decoders and converters (output not shown here as it is very extensive).</p>
<p>&lt;&lt;converterFunc,echo=TRUE,eval=FALSE&gt;&gt;= SosEncodingFunctions() SosParsingFunctions() SosDataFieldConvertingFunctions() @</p>

<p>The method <code><a href="../reference/SOS.html">SOS()</a></code> is a construction method for classes encapsulating a connection to a SOS. It prints out a short statement when the connection was successfully established (i.e. the capabilities document was received) and returns an object of class <code>SOS</code>.</p>
<p>&lt;&lt;connInternal,echo=FALSE,eval=TRUE&gt;&gt;= .fileMySOS &lt;- “mySOS.RData” if(.goOnline) { mySOS &lt;- SOS(url = “<a href="http://sensorweb.demo.52north.org/sensorwebtestbed/sos/kvp" class="uri">http://sensorweb.demo.52north.org/sensorwebtestbed/sos/kvp</a>”, binding = “KVP”) save(mySOS, file = .fileMySOS) } else { load(.fileMySOS) } @</p>
<p>&lt;&lt;conn,echo=TRUE,eval=FALSE&gt;&gt;= mySOS &lt;- SOS(url = “<a href="http://sensorweb.demo.52north.org/sensorwebtestbed/sos/kvp" class="uri">http://sensorweb.demo.52north.org/sensorwebtestbed/sos/kvp</a>”, binding = “KVP”) @</p>
<p>To create a SOS connection you only need the URL of the service (i.e. the URL endpoint which can be used for HTTP requests). The service connection created above is used for all examples throughout this document.</p>
<p>All parameters except the service endpoint are optional and use default settings (see also section ):</p>

<p>There are accessor methods for the slots of the class. The encoders, parsers and converters are described extensively in section .</p>
<p>&lt;&lt;connDetails1,echo=TRUE,eval=FALSE&gt;&gt;= sosUrl(mySOS) sosTitle(mySOS) sosAbstract(mySOS) sosVersion(mySOS) sosTimeFormat(mySOS) sosBinding(mySOS) @</p>
<p>&lt;&lt;connDetails2,echo=TRUE,eval=FALSE&gt;&gt;= sosEncoders(mySOS) sosParsers(mySOS) sosDataFieldConverters(mySOS) @</p>
<p>Print and summary methods are available for important classes, like <code>SOS</code>.</p>
<p>&lt;&lt;connDetails3,echo=TRUE,eval=TRUE&gt;&gt;= mySOS summary(mySOS) @</p>

<p> implements the SOS core profile of version 1.0.0 comprising the operations GetCapabilities, DescribeSensor and GetObservation. This document focusses on the practical usage of the operations, so the reader is refered to the specification document for details.</p>
<p>The methods mirroring the SOS operations all contain debugging parameters <code>inspect</code> and <code>verbose</code> as described in section .</p>

<p>The GetCapabilities operations is automatically conducted during the connecting to a SOS instance. The response is the , which contains a detailed description of the services capabilities. It’s sections describe: service identification, service provider, operations metadata (parameter names, ), filter capabilities, and contents (a list of offering descriptions). Please see section 8.2.3 of the SOS specification for details. If you want to inspect the original capabilities document it can be re-requested using</p>
<p>&lt;&lt;capsOriginal,echo=TRUE,eval=FALSE&gt;&gt;= sosCapabilitiesDocumentOriginal(sos = mySOS) @</p>
<p>The actual operation can be started with the following function. It returns an object of class <code>SosCapabilities</code> which can be accessed later on by the function <code><a href="../reference/SOS.html">sosCaps()</a></code> from an object of class <code>SOS</code>.</p>
<p>&lt;&lt;getCap1,echo=TRUE,eval=FALSE&gt;&gt;= getCapabilities(sos = mySOS) @</p>
<p>The parameters of the operation are:</p>


<p>The respective  are modelled as R classes and can be accessed with these functions:</p>
<p>&lt;&lt;getCap2,echo=TRUE,eval=FALSE&gt;&gt;= sosServiceIdentification(mySOS) sosServiceProvider(mySOS) sosFilter_Capabilities(mySOS) sosContents(mySOS) @</p>
<p>The first four functions extract clearly structured, self-explanatory parts of the document, so no further discussion is made here. The contents part however is described in detail in section , as it can (and should) be used to extract query parameters.</p>
<p>The function <code><a href="../reference/SOS.html">sosTime()</a></code> returns the time period for which observations are available within the service. To be precise, it accesses the ows:Range element of the parameter eventTime in the description of the GetObservation operation.</p>
<p>&lt;&lt;getCap3,echo=TRUE,eval=TRUE&gt;&gt;= sosTime(mySOS) @</p>
<p>The operations supported by the SOS are listed in the ows:OperationsMetadata element, which is modelled as an R class, <code>OwsOperationsMetadata</code>, which contains a list of objects of class <code>OwsOperation</code> which in turn describe the allowed parameter values for calls to the operation. The operations metadata and individual operations can be inspected with the following functions.</p>
<p>&lt;&lt;getCap4,echo=TRUE,eval=FALSE&gt;&gt;= sosOperationsMetadata(mySOS) sosOperation(mySOS, “GetCapabilities”) sosOperation(mySOS, sosGetCapabilitiesName) @</p>
<p>The allowed response formats (the file format/encoding of the response), the response modes (for example inline or as attachment) and the result models (a qualified XML name of the root element of the response) differ for every operation of the service. The following accessor methods return either (i) a list (named by the operation names) of vectors (with the actual allowed parameter values), or (ii) with the <code>unique</code> parameter set to <code>TRUE</code>, a unique list of all allowed values. Please be aware that these are not allowed for all operations, not are all options supported by .</p>
<p>&lt;&lt;getCap5,echo=TRUE,eval=FALSE&gt;&gt;= sosResponseFormats(mySOS) sosResponseMode(mySOS) sosResultModels(mySOS) @</p>
<p>Some exemplary outputs of the operations are as follows (unnamed lists are simplified with <code><a href="https://www.rdocumentation.org/packages/base/topics/toString">toString()</a></code>). Note the missing values for some operations (where options are not required they might not be available).</p>
<p>&lt;&lt;getCap6a,echo=TRUE,eval=FALSE&gt;&gt;= sosResponseMode(mySOS, unique = TRUE) @ &lt;&lt;getCap6b,echo=FALSE,eval=TRUE&gt;&gt;= toString(sosResponseMode(mySOS, unique = TRUE)) @</p>
<p>&lt;&lt;getCap7,echo=TRUE,eval=TRUE&gt;&gt;= sosResultModels(mySOS)[1:3] @</p>
<p>&lt;&lt;getCap8a,echo=TRUE,eval=FALSE&gt;&gt;= sosResponseMode(mySOS)[[sosGetObservationByIdName]] @ &lt;&lt;getCap8b,echo=FALSE,eval=TRUE&gt;&gt;= toString(sosResponseMode(mySOS)[[sosGetObservationByIdName]]) @</p>
<p>&lt;&lt;getCap9a,echo=TRUE,eval=FALSE&gt;&gt;= sosResultModels(mySOS)[[sosGetObservationName]][3:4] @ &lt;&lt;getCap9b,echo=FALSE,eval=TRUE&gt;&gt;= toString(sosResultModels(mySOS)[[sosGetObservationName]]) @</p>
<p>&lt;&lt;getCap10Internal,echo=TRUE,eval=FALSE&gt;&gt;= sosResponseFormats(mySOS)[[sosGetObservationByIdName]] @ &lt;&lt;getCap10,echo=FALSE,eval=TRUE&gt;&gt;= toString(paste(sosResponseFormats(mySOS)[[sosGetObservationByIdName]])) @</p>

<p>For future analyses, but also for correct plotting, one must know the coordinate reference system (CRS) or spatial reference system (SRS) or the returned data. You can get this information using the method <code><a href="../reference/SOS.html">sosGetCRS()</a></code> from variuos objects.</p>
<p>The function utilizes the EPSG code in GML attributes like <code>srsName="urn:ogc:def:crs:EPSG:4326"</code> to initialize an object of class <code>CRS</code> from the package . For <code>SOS</code> and code{SosObservationOffering} objects these are taken from the bounding box given in the <code>gml:boundedBy</code> element.</p>
<p>&lt;&lt;sosGetCRS,echo=TRUE,eval=TRUE&gt;&gt;= sosGetCRS(“<a href="urn:ogc:def:crs:EPSG:4326" class="uri">urn:ogc:def:crs:EPSG:4326</a>”)</p>
<div id="returns-the-crs-of-offerings-based-on-the-crs" class="section level1">
<h1 class="hasAnchor">
<a href="#returns-the-crs-of-offerings-based-on-the-crs" class="anchor"></a>returns the CRS of offering(s) based on the CRS</h1>
</div>
<div id="used-in-the-element-gmlboundedby" class="section level1">
<h1 class="hasAnchor">
<a href="#used-in-the-element-gmlboundedby" class="anchor"></a>used in the element gml:boundedBy:</h1>
<p>sosGetCRS(mySOS)[1:2]</p>
<p>sosGetCRS(sosOfferings(mySOS)[[1]]) @</p>
<p>Mre examples for <code>sosGetSRS()</code> can be found in section .</p>

<p>The content of the capabilities document allows the plotting of a service’s offerings. The following example uses the packages ,  and  to create a background map. Plotting functions exist for objects of class <code>SOS</code> (see Figure ) and <code>SosObservationOffering</code>, so offerings can also be plotted separately.</p>
<p>&lt;&lt;sosPlot,include=FALSE&gt;&gt;= # background map: library(maps); library(mapdata); library(maptools) data(worldHiresMapEnv) crs &lt;- sosGetCRS(mySOS)[[1]] worldHigh &lt;- pruneMap( map(database = “worldHires”, region = c(“Germany”, “Austria”, “Netherlands”), plot = FALSE)) worldHigh.lines &lt;- map2SpatialLines(worldHigh, proj4string = crs)</p>
</div>
<div id="the-plot" class="section level1">
<h1 class="hasAnchor">
<a href="#the-plot" class="anchor"></a>the plot:</h1>
<p>plot(worldHigh.lines, col = “grey50”) plot(mySOS, add = TRUE, lwd = 3) title(main = paste(“Offerings by ‘“, sosTitle(mySOS),”’”, sep = ""), sub = toString(names(sosOfferings(mySOS)))) @</p>

<p>See the demos (section ) for more detailed examples of plotting.</p>

<p>The DescribeSensor operation is specified in clause 8.3 of the SOS specification and its response is modeled in Sensor Model Language (SensorML) and Transducer Markup Language (TML) specifications.</p>

<p>The parameters of the operation are as follows. Please see section  and  of this document for supported values respectively allowed values of request parameters.</p>

<p>A simple example is as follows.</p>
<p>&lt;&lt;describeSensor1a,echo=FALSE,results=‘hide’&gt;&gt;= .sensorFile &lt;- “mySensor” if (.goOnline) { mySensor &lt;- describeSensor(sos = mySOS, # verbose = TRUE procedure = “wxt520”, outputFormat = ‘text/xml; subtype=“sensorML/1.0.1”’, saveOriginal = .sensorFile) } else { mySensor &lt;- parseFile(mySOS, .getFilePath(.sensorFile), verbose = .verbose) } @ &lt;&lt;describeSensor1b,echo=TRUE,eval=FALSE&gt;&gt;= # manual assignment used because procedure order might change: mySensor &lt;- describeSensor(sos = mySOS, procedure = “wxt520”, outputFormat = ‘text/xml; subtype=“sensorML/1.0.1”’)</p>
</div>
<div id="using-procedure-referencing" class="section level1">
<h1 class="hasAnchor">
<a href="#using-procedure-referencing" class="anchor"></a>using procedure referencing:</h1>
<p>myOtherSensor &lt;- describeSensor(sos = mySOS, procedure = sosProcedures(obj = mySOS)[[1]][[1]], outputFormat = “<a href="http://www.opengis.net/sensorML/1.0.1" class="uri">http://www.opengis.net/sensorML/1.0.1</a>”) @ &lt;&lt;describeSensor1c,echo=FALSE,eval=TRUE&gt;&gt;= mySensor @</p>
<p>All additional information presented in the following depends on compliance of the sensor description with the SensorML Profile for Discovery).</p>
<p>The coordinates data frame of a sensor description can be accessed with the common method <code><a href="../reference/SOS.html">sosCoordinates()</a></code>.</p>
<p>&lt;&lt;describeSensor2,echo=TRUE,eval=FALSE&gt;&gt;= sosCoordinates(mySensor) @</p>
<p>Other possibly useful parts of the sensor description can be accessed as well:</p>
<p>&lt;&lt;describeSensor3,echo=TRUE&gt;&gt;= sosId(mySensor) sosName(mySensor) sosAbstract(mySensor) @</p>
<p>This includes the coordinates with unit and reference system information in the attributes of the returned object. The observed bounding box is also available.</p>
<p>&lt;&lt;describeSensorCoords,echo=TRUE&gt;&gt;= mySensor.coords &lt;- sosCoordinates(mySensor) attributes(mySensor.coords) sosBoundedBy(mySensor) @</p>
<p>The coordinates also allow the plotting of the sensor positions (see Figure ). Here it is assumed that the spatial reference system of the SOS is the same for data from the first offering and the sensor positions!</p>
<p>&lt;&lt;describeSensorPlotCodeForText,echo=TRUE,eval=FALSE&gt;&gt;= library(maps); library(mapdata); library(maptools) data(worldHiresMapEnv)</p>
</div>
<div id="get-sensor-descriptions" class="section level1">
<h1 class="hasAnchor">
<a href="#get-sensor-descriptions" class="anchor"></a>get sensor descriptions</h1>
<p>procs &lt;- unique(unlist(sosProcedures(mySOS))) procs.descr &lt;- lapply(X = procs, FUN = describeSensor, sos = mySOS)</p>
<p>sensors.crs &lt;- unique(sosGetCRS(procs.descr))[[1]] worldHigh &lt;- pruneMap(map(database = “worldHires”, region = c(“Germany”, “Austria”, “Netherlands”, “Italy”), plot = FALSE)) worldHigh.lines &lt;- map2SpatialLines(worldHigh, proj4string = sensors.crs)</p>
<p>plot(worldHigh.lines, col = “grey50”, ylim = c(44.0, 54.8)) for(x in procs.descr) plot(x, add = TRUE, pch = 19) text(sosCoordinates(procs.descr)[c(“x”, “y”)], labels = sosId(procs.descr), pos = 4, cex = 0.8) title(main = paste(“Sensors of”, sosTitle(mySOS))) @</p>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<p>The GetObservation operation is specified in clause 8.4 of the SOS specification. In this section, all matters around requesting data are explained — from extracting query parameters from metadata, and sending the request, till finally extracting data values and coordinates from the response.</p>
<p>A few utility functions exist to minize a user’s amount of work to create usual requests. They accept normal R types as input and return the respective class from  with useful default settings. These function’s names follow the pattern with <code>sosCreate [name of object] ()</code> and exist for spatial and temporal filters.</p>

<p>It is recommended to extract the identifiers of procedures et cetera that are to be used for queries from the metadata description provided by the service, the capabilities document (see section . This often ensures forward compatiblity and minimizes typing errors. The offerings are the  of the service and therefore we concentrate on the contents section of the capabilities here.</p>
<p>The class <code>SosContents</code> simply contains a list of objects of the class <code>SosObservationOffering</code> which one can get directly from the connection object:</p>
<p>&lt;&lt;metadataExtraction1Internal,echo=TRUE,eval=FALSE&gt;&gt;= sosOfferings(mySOS) sosOfferings(mySOS, name = “wxt520”) @</p>
<p>The output when printing this list is quite extensive, so we concentrate on just on element of it in the following examples. Printing and summary methods are available of objects of the class <code>SosObservationOffering</code>.</p>
<p>&lt;&lt;metadataExtraction1,echo=TRUE,eval=TRUE&gt;&gt;= summary(sosOfferings(mySOS)[[1]]) @</p>
<p>The offerings list is named with the offering identifier, so the following statements return the same list.</p>
<p>&lt;&lt;metadataExtraction2,echo=TRUE,eval=FALSE&gt;&gt;= sosOfferingIds(mySOS) names(sosOfferings(mySOS)) sosName(sosOfferings(mySOS)) @</p>
<p>The offering identifier is is used in the example below to extract the offering description of temperature measurements. The offerings list is a standard R list, so all subsetting operations are possible.</p>
<p> The order of the offering list (as all other lists, e.g. procedures or observed properties) is not guaranteed to be the same upon every connection to a service. So indexing by name (though counteracting the mentioned forward compatibility, as names might change) is recommended at at least one point in the analysis so that changes in the contents of a service result in an error.</p>
<p>&lt;&lt;metadataExtraction3,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt &lt;- sosOfferings(mySOS)[[“wxt520”]] @</p>
<p>Metadata about the whole  are identifier, name, and spatial and temporal extends.</p>
<p>&lt;&lt;metadataExtraction4,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt.id &lt;- sosId(off.wxt) off.wxt.name &lt;- sosName(off.wxt) @</p>
<p>The offerings also contains metadata about the format and model that are supported.</p>
<p>&lt;&lt;metadataExtraction4b,echo=TRUE,eval=TRUE&gt;&gt;= sosResultModels(off.wxt) sosResponseMode(off.wxt) sosResponseFormats(off.wxt) @</p>
<p>The  is given as a rectangular bounding box with two coordinates. The structure of the bounding box is kept flexible, as it simply returns a named list of lower and upper corner.</p>
<p>&lt;&lt;metadataExtraction5,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt.boundedBy &lt;- sosBoundedBy(off.wxt) @</p>
<p>The optional attribute <code>bbox</code> can be used to obtain a bounding box matrix as used by package .</p>
<p>&lt;&lt;metadataExtraction6,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt.boundedBy.bbox &lt;- sosBoundedBy(off.wxt, bbox = TRUE) @</p>
<p>The  is modeled as an object of the respective class of the element in the offering description, which normally is a gml:TimePeriod, but does not have to be. The last two statements in the following snipped show how one can access the actual data and what their class is.</p>
<p>&lt;&lt;metadataExtraction7,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt.time &lt;- sosTime(off.wxt) str(off.wxt.time)</p>
<p><a href="mailto:off.wxt.time@beginPosition@time">off.wxt.time@beginPosition@time</a> <a href="mailto:off.wxt.time@endPosition@time">off.wxt.time@endPosition@time</a> class(<a href="mailto:off.wxt.time@endPosition@time">off.wxt.time@endPosition@time</a>) @</p>
<p>The structure of these elements is very flexible (with some of optional elements) and not self-explanatory. Therefore the parameter <code>convert</code> can be used to try to create R objects and return these instead. Please be aware that this might not work for temporal elements returned by all service.</p>
<p>&lt;&lt;metadataExtraction8,echo=TRUE,eval=TRUE&gt;&gt;= off.wxt.time.converted &lt;- sosTime(off.wxt, convert = TRUE) str(off.wxt.time.converted) @</p>
<p>Furthermore the offering comprises , , and . In our example the feature and procedure identifiers are the same — this does not have to be the case.</p>
<p> The order of these lists is not guaranteed to be the same upon every connection to a service.</p>
<p>&lt;&lt;metadataExtraction9,echo=TRUE,eval=TRUE&gt;&gt;= sosProcedures(off.wxt) sosObservedProperties(off.wxt) sosFeaturesOfInterest(off.wxt) @</p>
<p>All of the above can not only be requested for single offerings but also for complete SOS connections or for lists of offerings. The following examples only print out a part of the returned lists.</p>
<p>&lt;&lt;metadataExtraction10Internal,echo=TRUE,eval=TRUE&gt;&gt;= sosProcedures(mySOS)[1:2] sosObservedProperties(mySOS)[1:2] sosFeaturesOfInterest(mySOS)[1:2] @</p>
<p>Also (parts of) a list of offerings are possible with these functions:</p>
<p>&lt;&lt;metadataExtraction10,echo=TRUE,eval=TRUE&gt;&gt;= sosProcedures(sosOfferings(mySOS)[2:3]) sosObservedProperties(sosOfferings(mySOS)[2:3]) sosFeaturesOfInterest(sosOfferings(mySOS)[1:4]) @</p>
<p>Please carefully inspect the structure in each case, as these functions will return named lists of lists and not combine procedures from different offerings. Consequently, some procedures could appear several times, but the association to the offering is still intact which is preferred at this stage.</p>

<p>&lt;&lt;getObservation,eval=FALSE,echo=TRUE&gt;&gt;= getObservation(sos = mySOS, offeringy = myOffering, …) @</p>
<p>The mandatory attributes are <code>sos</code>, <code>offering</code>, <code>observedProperty</code> and <code>responseFormat</code>. The other parameters are set to <code>NA</code> and not used when building the request.</p>
<p>Please see section 8.4.2 of the SOS specification for details, and section  and  of this document for supported values respectively allowed values of request parameters. Note that different implementations might respond differently to missing parameters.</p>
<p>&lt;&lt;defaultValue,echo=FALSE,eval=TRUE&gt;&gt;= defaultResponseFormatGetObs &lt;- gsub(pattern = ""“, replacement =”’", x = sosDefaultGetObsResponseFormat) @</p>

<p>The returned data of all GetObservation operations is an XML document of type om:Observation, om:Measurement, or om:ObservationCollection which holds a list of the former two. All three of these have corresponding S4 classes, namely <code>OmObservation</code>, <code>OmMeasurement</code>, or <code>OmObservationCollection</code>.</p>
<p>The most straightforward (and most simple to use) methods to query certain observations are to request one (or several) specific  (phenomenon) or  (sensor). Note that the procedures and observed properties have to match the given offering.</p>
<p>&lt;&lt;getObsPropPhen,eval=FALSE,echo=TRUE&gt;&gt;= obs.wxt.procedure.1 &lt;- getObservation(sos = mySOS, offering = off.wxt, procedure = sosProcedures(off.wxt)[[2]])</p>
<p>obs.wxt.offering.34 &lt;- getObservation(sos = mySOS, offering = off.wxt, procedure = sosProcedures(off.wxt), observedProperty = sosObservedProperties(mySOS)[3:4]) @</p>
<p>These request would potentially retrieve a lot of data, since there is no temporal (or thematical/spatial) limitation. The following example requests data for about one day of temperature data and stores it in the object <code>obs.wxt</code>. This feature is described extensively in section .</p>
<p>&lt;&lt;loadOrDownload_ObsTemp,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= .obsFile &lt;- “obs.wxt” if (.goOnline) { obs.wxt &lt;- getObservation(sos = mySOS, offering = off.wxt, eventTime = sosCreateTime(sos = mySOS, time = “2015-11-01::2015-11-02”), saveOriginal = .obsFile) } else { obs.wxt &lt;- parseFile(mySOS, .getFilePath(.obsFile)) } @ % not executed &lt;&lt;getObs0a,eval=FALSE&gt;&gt;= obs.wxt &lt;- getObservation(sos = mySOS, offering = off.wxt, eventTime = sosCreateTime(sos = mySOS, time = “2015-11-01::2015-11-02”)) @</p>
<p>The logging output above starting with <code>[sos4R]</code> informs the user when the download of data is complete and when the parsing has finished. It even contains some information about the data, if possible. In following requests, this ouput is  included for brevity.</p>
<p>The response <code>obs.wxt</code> of this request is the base for the next sections.</p>
<p>&lt;&lt;getObs1a,eval=TRUE,echo=TRUE&gt;&gt;= class(obs.wxt) str(obs.wxt, max.level = 2) @</p>

<p>Subsetting of elements in an <code>OmObservationCollection</code> can be done just like in a normal list (in fact, it just wraps at list of observations at this point), i.e. with the operators <code>[</code> and <code>[[</code>. Summary functions are available for single observations or an observation collection.</p>
<p>&lt;&lt;getObs1b,eval=TRUE,echo=TRUE&gt;&gt;= length(obs.wxt) obs.wxt[[1]] summary(obs.wxt) summary(obs.wxt[[1]]) @</p>
<p>The collection can also be subset in parts:</p>
<p>&lt;&lt;getObs1c,eval=FALSE,echo=TRUE&gt;&gt;= obs.wxt[2:3] @</p>
<p> is possible with identifiers of procedure(s), observed property(ies), and feature(s) of interest.</p>
<p>&lt;&lt;getObs1d,eval=TRUE,echo=TRUE&gt;&gt;= index.foiId &lt;- sosFeaturesOfInterest(off.wxt)[[1]] index.foiId obs.wxt[index.foiId]</p>
<p>index.obsProp &lt;- sosObservedProperties(off.wxt)[[1]] obs.wxt[index.obsProp]</p>
<p>index.obsProp.several &lt;- sosObservedProperties(off.wxt)[4:6] obs.wxt[index.obsProp.several]</p>
<p>index.proc &lt;- sosProcedures(off.wxt) index.proc.alternative1 &lt;- sosProcedures(off.wxt)[1] index.proc.alternative2 &lt;- sosProcedures(mySOS) obs.wxt[index.proc] @</p>

<p> can be extracted from observations, measurements and observation collections with the function <code><a href="../reference/OmObservation.html">sosResult()</a></code>. The function returns an object of class <code>data.frame</code>. In the case of collections, it automatically binds the data frames (you can turn this off by adding <code>bind = FALSE</code> as a parameter).</p>
<p>&lt;&lt;getObs2,eval=TRUE,echo=TRUE&gt;&gt;= names(obs.wxt) obs.wxt.result.2 &lt;- sosResult(obs.wxt[[2]]) # FIXME: # obs.wxt.result &lt;- sosResult(obs.wxt[1:2]) @</p>
<p>Additional metadata, like units of measurement or definitions, is accessible via <code><a href="https://www.rdocumentation.org/packages/base/topics/attributes">attributes()</a></code> for every column of the data frame.</p>
<p>&lt;&lt;getObs3,eval=TRUE,echo=TRUE&gt;&gt;= attrs &lt;- attributes(obs.wxt.result.2) # [[“AirTemperature”]]</p>
<p>attributes(obs.wxt.result.2[[“phenomenonTime”]]) attributes(obs.wxt.result.2[[“AthmosphericPressure”]]) @</p>
<p> can be stored in an observation in several ways: (i) as a usual data attribute which is directly contained in the result <code>data.frame</code>, (ii) within a feature collection in the observation. In the latter case the utility functions <code><a href="../reference/SOS.html">sosCoordinates()</a></code> and <code><a href="../reference/SOS.html">sosFeatureIds()</a></code> can be used to extract the coordinates respectively the identifiers from <code>OmObservationCollection</code> or <code>OmObservation</code> classes. A variety of feature types gml:Point or sa:SamplingPoint are supported by <code><a href="../reference/SOS.html">sosCoordinates()</a></code>.</p>
<p>&lt;&lt;getObsSpatial1a,eval=TRUE,echo=TRUE&gt;&gt;= obs.wxt.foiIDs &lt;- sosFeatureIds(obs.wxt) obs.wxt.coords &lt;- sosCoordinates(obs.wxt) obs.wxt.coords.1 &lt;- sosCoordinates(obs.wxt[[1]]) @</p>
<p>An observation collection also contains a bounding box of the contained observations, which can be extracted with the function <code><a href="../reference/SOS.html">sosBoundedBy()</a></code>. The optional attribute <code>bbox</code> can be used to obtain a bounding box matrix as used by package .</p>
<p>&lt;&lt;getObsSpatial1b,eval=TRUE,echo=TRUE&gt;&gt;= sosBoundedBy(obs.wxt) sosBoundedBy(obs.wxt, bbox = TRUE) @</p>
<p>The combination of data values and coordinates strongly depends on the use case and existing spatial information. In the case of coordinates encoded in the features, a matching of the two data frames can easily be accomplished manually with the function <code><a href="https://www.rdocumentation.org/packages/base/topics/merge">merge()</a></code>.</p>
<p>&lt;&lt;getObsSpatial2,eval=TRUE,echo=TRUE&gt;&gt;= # FIXME: #result.names &lt;- names(obs.wxt.result) coords.names &lt;- names(obs.wxt.coords) # print(toString(result.names)) print(toString(coords.names))</p>
</div>
<div id="fixme" class="section level1">
<h1 class="hasAnchor">
<a href="#fixme" class="anchor"></a>FIXME</h1>
</div>
<div id="obs-wxt-data---merge" class="section level1">
<h1 class="hasAnchor">
<a href="#obs-wxt-data---merge" class="anchor"></a>obs.wxt.data &lt;- merge(</h1>
</div>
<div id="x-obs-wxt-result" class="section level1">
<h1 class="hasAnchor">
<a href="#x-obs-wxt-result" class="anchor"></a>x = obs.wxt.result,</h1>
</div>
<div id="y-obs-wxt-coords" class="section level1">
<h1 class="hasAnchor">
<a href="#y-obs-wxt-coords" class="anchor"></a>y = obs.wxt.coords,</h1>
</div>
<div id="by-x-result-names2" class="section level1">
<h1 class="hasAnchor">
<a href="#by-x-result-names2" class="anchor"></a>by.x = result.names[[2]],</h1>
</div>
<div id="by-y-coords-names4" class="section level1">
<h1 class="hasAnchor">
<a href="#by-y-coords-names4" class="anchor"></a>by.y = coords.names[[4]])</h1>
<p>@</p>
<p>The default column name for the feature identifiers is <code>\Sexpr{sosDefaultColumnNameFeatureIdentifier</code>}. If the name of the feature identifier attribute in the data table matches (which is the case for SOS), <code>merge</code> does not need additional information. In that case, the merging reduces to the following code:</p>
<p>&lt;&lt;getObsSpatial3,eval=TRUE,echo=TRUE&gt;&gt;= obs.wxt.data &lt;- merge(x = obs.wxt.result.2, y = obs.wxt.coords) str(obs.wxt.data, max.level = 2) @</p>
<p>And in that case, you can even save that step by specifying the attribute <code>coordinates</code> of the function <code>sosResult</code> which includes the merge of data values and coordinates as shown above.</p>
<p>&lt;&lt;getObsSpatial4,eval=FALSE,echo=TRUE&gt;&gt;= head(sosResult(obs.wxt[1], coordinates = TRUE)) @</p>

<p>The possibly most typical temporal filter is a period of time for which measurements are of interest.</p>
<p>&lt;&lt;temporalFiltering1a,eval=TRUE,echo=TRUE&gt;&gt;= # temporal interval creation based on POSIXt classes: lastWeek.period &lt;- sosCreateTimePeriod(sos = mySOS, begin = (Sys.time() - 3600 * 24 * 7), end = Sys.time())</p>
<p>oneWeek.period &lt;- sosCreateTimePeriod(sos = mySOS, begin = as.POSIXct(“2015/11/01”), end = as.POSIXct(“2015/11/07”)) oneWeek.eventTime &lt;- sosCreateEventTimeList(oneWeek.period) @</p>
<p>Please note that the create function <code><a href="../reference/sosCreate.html">sosCreateEventTimeList()</a></code> wraps the created objects in a list as required by the method <code><a href="../reference/getObservation-methods.html">getObservation()</a></code>.</p>
<p>The most comfortable creation function for event times is <code><a href="../reference/sosCreate.html">sosCreateTime()</a></code>. It supports time intervals with starttime and endtime as character strings seperated by <code>::</code> or <code>/</code> as defined by ISO 8601. The respective time stamps have to be parsable by <code><a href="https://www.rdocumentation.org/packages/base/topics/as.POSIXlt">as.POSIXct()</a></code>. If either one of the time stamps is missing, a <code>GmlTimePosition</code> wrapped in the appropriate relative temporal operator, e.g. .</p>
<p>&lt;&lt;temporalFiltering1b,eval=TRUE,echo=TRUE&gt;&gt;= sosCreateTime(sos = mySOS, time = “2007-07-07 07:00::2008-08-08 08:00”) sosCreateTime(sos = mySOS, time = “2007-07-07 07:00/2010-10-10 10:00”)</p>
<p>sosCreateTime(sos = mySOS, time = “::2007-08-05”) sosCreateTime(sos = mySOS, time = “2007-08-05/”) @</p>
<p> What was the minimum, average and maximum temperature during one week?</p>
<p>&lt;&lt;loadOrDownload_TemporalFiltering2,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= .obsFile &lt;- “obs.oneWeek” if(.goOnline) { obs.oneWeek &lt;- getObservation(sos = mySOS, offering = off.wxt, procedure = sosProcedures(off.wxt), observedProperty = sosObservedProperties(off.wxt)[c(1,2,13)], eventTime = oneWeek.eventTime, saveOriginal = .obsFile) } else { obs.oneWeek &lt;- parseFile(mySOS, .getFilePath(.obsFile)) } @ &lt;&lt;temporalFiltering2a,eval=FALSE,echo=TRUE&gt;&gt;= obs.oneWeek &lt;- getObservation(sos = mySOS, offering = off.wxt, # actually not required, as default is ‘all procedures’: procedure = sosProcedures(off.wxt), eventTime = oneWeek.eventTime) @ &lt;&lt;temporalFiltering2b,eval=TRUE,echo=TRUE&gt;&gt;= obs.oneWeek.result &lt;- sosResult(obs.oneWeek[[1]]) head(obs.oneWeek.result) # FIXME # summary(obs.oneWeek.result[,“<a href="urn:ogc:def:property:OGC" class="uri">urn:ogc:def:property:OGC</a>::Temperature”]) @</p>
<p>The default temporal operator is , but others are supported as well (see section ). The next example shows how to create a temporal filter for all observations taken  a certain point in time. Here the creation function creates just one object of class <code>SosEventTime</code> which must be added to a list manually before passing it to <code><a href="../reference/getObservation-methods.html">getObservation()</a></code>.</p>
<p>&lt;&lt;temporalFiltering3,eval=TRUE,echo=TRUE&gt;&gt;= lastDay.instant &lt;- sosCreateTimeInstant( time = as.POSIXct(Sys.time() - 3600 * 24), sos = mySOS) lastDay.eventTime &lt;- sosCreateEventTime(time = lastDay.instant, operator = SosSupportedTemporalOperators()[[“TM_After”]]) print(lastDay.eventTime) @</p>

<p>The possibly most typical spatial filter is a bounding box within which measurements of interest must have been made. Here the creation function returns an object of class <code>OgcBBOX</code>, which can be wrapped in an object of class <code>SosFeatureOfInterest</code>, which is passed into the get-observation call.</p>
<p>&lt;&lt;spatialFiltering1a,eval=TRUE,echo=TRUE&gt;&gt;= sept15.period &lt;- sosCreateTimePeriod(sos = mySOS, begin = as.POSIXct(“2015-09-01 00:00”), end = as.POSIXct(“2015-09-30 00:00”)) sept15.eventTimeList &lt;- sosCreateEventTimeList(sept15.period) @</p>
<p>&lt;&lt;loadOrDownload_SpatialFiltering,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= # FIXME find a spatial filter that has a result # .obsFile &lt;- “obs.sept15” # .obsFile2 &lt;- “obs.sept15.bbox” # if(.goOnline) { # obs.sept15 &lt;- getObservation(sos = mySOS, # offering = off.wxt, # eventTime = sept15.eventTimeList, # saveOriginal = .obsFile) # # request.bbox &lt;- sosCreateBBOX(lowLat = 50.0, lowLon = 5.0, # uppLat = 55.0, uppLon = 10.0, # srsName = “<a href="urn:ogc:def:crs:EPSG:4326" class="uri">urn:ogc:def:crs:EPSG:4326</a>”) # request.bbox.foi &lt;- sosCreateFeatureOfInterest( # spatialOps = request.bbox) # # obs.sept15.bbox &lt;- getObservation(sos = mySOS, # offering = off.wxt, # featureOfInterest = request.bbox.foi, # eventTime = sept15.eventTimeList, # saveOriginal = .obsFile2) # } else { # obs.sept15 &lt;- parseFile(mySOS, .getFilePath(.obsFile)) # obs.sept15.bbox &lt;- parseFile(mySOS, .getFilePath(.obsFile2)) # } @ &lt;&lt;spatialFiltering2,eval=FALSE,echo=TRUE&gt;&gt;= obs.sept15 &lt;- getObservation(sos = mySOS, offering = off.wxt, eventTime = sept15.eventTimeList) @</p>
<p>&lt;&lt;spatialFiltering3,eval=FALSE,echo=TRUE&gt;&gt;= # FIXME find a spatial filter that has a result # request.bbox &lt;- sosCreateBBOX(lowLat = 50.0, lowLon = 5.0, # uppLat = 55.0, uppLon = 10.0, # srsName = “<a href="urn:ogc:def:crs:EPSG:4326" class="uri">urn:ogc:def:crs:EPSG:4326</a>”) # request.bbox.foi &lt;- sosCreateFeatureOfInterest( # spatialOps = request.bbox) # obs.sept09.bbox &lt;- getObservation(sos = mySOS, # offering = off.wxt, # featureOfInterest = request.bbox.foi, # eventTime = sept09.eventTimeList) @</p>
<p>Unfiltered versus spatially filtered coordinates of the responses:</p>
<p>&lt;&lt;spatialFiltering1b,eval=TRUE,echo=TRUE&gt;&gt;= # FIXME # print(sosCoordinates(obs.sept09)[,1:2]) # print(sosCoordinates(obs.sept09.bbox)[,1:2]) @</p>
<p>More advanced spatial filtering, for example based on arbitrary shapes et cetera, is currently not implemented. This could be implemented by implementing subclasses for <code>GmlGeometry</code> (including encoders) which must be wrapped in <code>OgcBinarySpatialOp</code> which extends <code>OgcSpatialOps</code> and can therefore be added to an object of class <code>SosFeatureOfInterest</code> as the spatial parameter.</p>

<p>The feature can not only be used for spatial filtering, but also to query specific FOIs. The following example extracts the identifiers from an offering and then creates an object of class <code>SosFeatureOfInterest</code>, which is passed into the get-observation call. Here the encoding function is called to show how the content of the result element will look like.</p>
<p>&lt;&lt;featureFiltering1,eval=TRUE,echo=TRUE&gt;&gt;= off.wxt.fois &lt;- sosFeaturesOfInterest(off.wxt) request.fois &lt;- sosCreateFeatureOfInterest( objectIDs = list(off.wxt.fois[[1]])) encodeXML(obj = request.fois, sos = mySOS) @</p>
<p>An exemplary GetObservation operation is as follows.</p>
<p>&lt;&lt;loadOrDownload_FeatureFiltering,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= .obsFile &lt;- “obs.oneWeek.fois” if(.goOnline) { obs.oneWeek.fois &lt;- getObservation(sos = mySOS, offering = off.wxt, featureOfInterest = request.fois, eventTime = oneWeek.eventTime, saveOriginal = .obsFile) } else { obs.oneWeek.fois &lt;- parseFile(mySOS, .getFilePath(.obsFile)) } @ &lt;&lt;featureFiltering1a,eval=FALSE,echo=TRUE&gt;&gt;= obs.oneWeek.fois &lt;- getObservation(sos = mySOS, offering = off.wxt, featureOfInterest = request.fois, eventTime = oneWeek.eventTime) @</p>
<p>&lt;&lt;featureFiltering1b,eval=TRUE,echo=TRUE&gt;&gt;= print(sosFeaturesOfInterest(obs.oneWeek.fois)) @</p>

<p>Value Filtering is realized via the slot <code>result</code> in a GetObservation request. The filtering in the request is based on comparison operators and operands specified by OGC Filter Encoding (Vretanos, 2005).</p>
<p>The classes and methods of this specification are not yet implemented, but manual definition of the XML elements is possible with the methods of the package .</p>
<p>The following code example uses a literal comparison of a property. The elements names are taken from constants within  (with the naming scheme ), but can equally as well be put in directly.</p>
<p>&lt;&lt;valueFiltering1,eval=TRUE,echo=TRUE&gt;&gt;= # result filtering filter.value &lt;- -2.3 filter.propertyname &lt;- xmlNode(name = ogcPropertyNameName, namespace = ogcNamespacePrefix) xmlValue(filter.propertyname) &lt;- “<a href="urn:ogc:def:property:OGC" class="uri">urn:ogc:def:property:OGC</a>::Temperature” filter.literal &lt;- xmlNode(name = ogcLiteralName, namespace = ogcNamespacePrefix) xmlValue(filter.literal) &lt;- as.character(filter.value) filter.comparisonop &lt;- xmlNode( name = ogcComparisonOpGreaterThanName, namespace = ogcNamespacePrefix, .children = list(filter.propertyname, filter.literal)) filter.result &lt;- xmlNode(name = sosResultName, namespace = sosNamespacePrefix, .children = list(filter.comparisonop)) @</p>
<p>Please consult to the extensive documentation of the  package for details. The commands above result in the following output which is inserted into the request without further processing.</p>
<p>&lt;&lt;valueFiltering2,eval=TRUE,echo=TRUE&gt;&gt;= filter.result @</p>
<p>Any object of class <code>OgcComparisonOpsOrXMLOrNULL</code>, which includes the class of the object returned by <code>xmlNode()</code>, i.e. <code>XMLNode</code>. These object can be used in the GetObservation request as the <code>result</code> parameter.</p>
<p>First, we request the unfiltered values for comparison, then again with the filter applied. The length of the returned results is compared in the end.</p>
<p>% has been requested before &lt;&lt;valueFiltering3a,eval=FALSE,echo=TRUE&gt;&gt;= obs.oneWeek &lt;- getObservation(sos = mySOS, eventTime = oneWeek.eventTime, offering = sosOfferings(mySOS)[[“wxt520”]]) @</p>
<p>&lt;&lt;loadOrDownload_ValueFiltering,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= .obsFile &lt;- “obs.oneWeek.filter” if(.goOnline) { obs.oneWeek.filter &lt;- getObservation(sos = mySOS, eventTime = oneWeek.eventTime, offering = sosOfferings(mySOS)[[“wxt520”]], result = filter.result, saveOriginal = .obsFile) } else { obs.oneWeek.filter &lt;- parseFile(mySOS, .getFilePath(.obsFile)) } @ &lt;&lt;valueFiltering3b,eval=FALSE,echo=TRUE&gt;&gt;= # request values for the week with a value higher than 0 degrees: obs.oneWeek.filter &lt;- getObservation(sos = mySOS, eventTime = oneWeek.eventTime, offering = sosOfferings(mySOS)[[“ATMOSPHERIC_TEMPERATURE”]], result = filter.result) &lt;&lt;valueFiltering3c,eval=TRUE,echo=TRUE&gt;&gt;= # FIXME # print(paste(“Filtered:”, dim(sosResult(obs.oneWeek.filter))[[1]], # “-vs.- Unfiltered:”, dim(sosResult(obs.oneWeek))[[1]])) @</p>

<p>A tighter integration with data structures of packages  or  (both available on CRAN) is planned for the future. Please consult the developers for the current status.</p>
<p>As an example the following code creates a <code>SpatialPointsDataFrame</code> (can only contain one data value per position!) based on the features of a result.</p>
<p>&lt;&lt;resultExporting1,eval=TRUE,echo=TRUE&gt;&gt;= library(“sp”) @</p>
<p>% ran before: &lt;&lt;resultExporting2,eval=FALSE,echo=TRUE&gt;&gt;= obs.oneWeek &lt;- getObservation(sos = mySOS, offering = off.wxt, procedure = sosProcedures(off.wxt), eventTime = oneWeek.eventTime) @</p>
<p>&lt;&lt;resultExporting3,eval=TRUE,echo=TRUE&gt;&gt;= # Create SpatialPointsDataFrame from result features coords &lt;- sosCoordinates(obs.oneWeek[[1]]) crs &lt;- sosGetCRS(obs.oneWeek[[1]]) spdf &lt;- SpatialPointsDataFrame(coords = coords[,1:2], data = data.frame(coords[,4]), proj4string = crs) str(spdf) @</p>

<p>For following analyses and plotting, the  can be extracted as follows (see section  for a general description).</p>
<p>&lt;&lt;getObsCRS,echo=TRUE,eval=TRUE&gt;&gt;= sosGetCRS(obs.wxt) sosGetCRS(obs.oneWeek) @</p>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<p>The operation GetObservationById is defined in clause 10.1 of the SOS specification and not part of the core profile. But it is implemented as it is quite simple. The response is the same as described in the previous section. Optional parameters, and their defaults and supported values (see sections  and ), are normally the same as in GetObservation requests.</p>
<p>In this case the returned observation collection contains an om:Measurement element, which contains just one measured value and is parsed to an object of class <code>OmMeasurement</code>.</p>
<p>The result extraction works the same as with objects of class <code>OmObservation</code>.</p>
<p>&lt;&lt;loadOrDownload_GetObsById,eval=TRUE,echo=FALSE,results=‘hide’&gt;&gt;= # Not supported by SOS anymore # .obsFile &lt;- “obsId” # if(.goOnline) { # obsId &lt;- getObservationById(sos = mySOS, # observationId = “o_3508493”, # saveOriginal = .obsFile) # } else { # obsId &lt;- parseFile(mySOS, .getFilePath(.obsFile)) # } @</p>
<p>%’ &lt;&lt;getObsById1a,eval=FALSE,echo=TRUE&gt;&gt;= %’ obsId &lt;- getObservationById(sos = mySOS, %’ observationId = “o_3508493”) %’ @ %’ &lt;&lt;getObsById1b,eval=TRUE,echo=TRUE&gt;&gt;= %’ sosResult(obsId, coordinates = TRUE) %’ @</p>
<p>Just as for <code><a href="../reference/getObservation-methods.html">getObservation()</a></code> you can  response document with an automatically generated name or a selected one. It is saved into the current working directory and the name starts with the observation identifier. You can also read it back using the function <code><a href="../reference/parse.html">sosParse()</a></code>.</p>
<p>&lt;&lt;getObsById3a,eval=FALSE,echo=TRUE&gt;&gt;= # generated file name, find file in working directory: # obsId &lt;- getObservationById(sos = mySOS, # observationId = “o_3508493”, # saveOriginal = TRUE) # .files &lt;- list.files(getwd()) # .observationFiles &lt;- c() # for(.f in .files) { # %in% not working with Sweave # if(length(grep(“^o_”, .f, value=TRUE)) &gt; 0) # .observationFiles &lt;- c(.observationFiles, .f) # } # obsId &lt;- parseFile(sos = mySOS, # file = .observationFiles[[1]])</p>
<p>&lt;&lt;getObsById3b,eval=FALSE,echo=TRUE&gt;&gt;= # manually selected file name: # obsId &lt;- getObservationById(sos = mySOS, # #verbose = TRUE, # observationId = “o_3508493”, # saveOriginal = “myObservation”) @</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#returns-the-crs-of-offerings-based-on-the-crs">returns the CRS of offering(s) based on the CRS</a></li>
      <li><a href="#used-in-the-element-gmlboundedby">used in the element gml:boundedBy:</a></li>
      <li><a href="#the-plot">the plot:</a></li>
      <li><a href="#using-procedure-referencing">using procedure referencing:</a></li>
      <li><a href="#get-sensor-descriptions">get sensor descriptions</a></li>
      <li><a href="#fixme">FIXME</a></li>
      <li><a href="#obs-wxt-data---merge">obs.wxt.data &lt;- merge(</a></li>
      <li><a href="#x-obs-wxt-result">x = obs.wxt.result,</a></li>
      <li><a href="#y-obs-wxt-coords">y = obs.wxt.coords,</a></li>
      <li><a href="#by-x-result-names2">by.x = result.names[[2]],</a></li>
      <li><a href="#by-y-coords-names4">by.y = coords.names[[4]])</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Daniel Nuest.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
