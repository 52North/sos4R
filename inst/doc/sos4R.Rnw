%
% http://cran.r-project.org/doc/manuals/R-exts.html#Writing-package-vignettes
% (Code chunks with option eval=FALSE are not tested.)
%

\documentclass[nogin,a4paper]{article}

%\VignetteIndexEntry{sos4R: Accessing Sensor Observation Services from R}

\usepackage{graphicx}
\usepackage{color}
\usepackage{Sweave}
\usepackage{csquotes}

\newcommand{\strong}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\fivetwon}{$52\,^{\circ}{\rm North}$ }
\newcommand{\code}[1]{{\tt #1}}
\let\pkg=\strong

\usepackage[colorlinks=true,urlcolor=blue,linkcolor=blue]{hyperref}

% otherwise removes line breaks etc.
\SweaveOpts{keep.source=TRUE}

\begin{document}

\title{Accessing Data from Sensor Observation Services:\\ the \pkg{sos4R} Package}
\author{Daniel N\"{u}st\footnote{Institute for Geoinformatics, University of Muenster, Germany.}\\ {\tt daniel.nuest@uni-muenster.de}\\ {\tt \url{http://www.nordholmen.net/sos4r}}}

\date{\today}

\maketitle

\begin{abstract}
The sos4R package provides easy and simple, yet powerful access to OGC Sensor Observation Service instances. The package supports both encapsulation and abstraction from the service interface for novice users as well as powerful request building for specialists.

sos4R is motivated by the idea to add a missing link between the Sensor Web and tools (geo-)statistical analyses. It implements the core profile of the SOS specification and supports temporal, spatial, and thematical filtering of observations. This document briefly introduces the SOS specification. The package's features are explained extensively: exploration of service metadata, request building with filters, function exchangeability, result data transformation.

The package is published under GPL~2 license within the geostatistics community of \fivetwon Initiative for Geospatial Open Source Software.

\end{abstract}

\tableofcontents

%<<load,echo=FALSE,print=FALSE,cache=FALSE>>=
%setCacheDir("/tmp/cacheSweave/sos4R")
%@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \pkg{sos4R} package provides classes and methods for retrieving data from an OGC Sensor Observation Service (Na, 2007). The goal of this package is to provide easy access with a low entry threshold for everyone to information available via SOSs. The complexity of the service interface shall be shielded from the user as much as possible, while still leaving enough possiblities for advanced users. At the current state, the output is limited to a standard data.frame with attributed columns for metadata.
In future releases a tighter integration is planned with upcoming space-time packages regarding data structures and classes. This package uses S4 classes and methods style (Chambers, 1998). 

The motivation to write this package was born out of perceiving a missing link between the Sensor Web community (known as Sensor Web Enablement (SWE) Initiative\footnote{\url{http://www.opengeospatial.org/projects/groups/sensorweb}} in the OGC realm) and the community of (geo-)statisticians. While the relatively young SWE standards get adopted more by data owners (like governmental organizations), we see a high but unused potential for more open data and spatio-temporal analyses based on it. \pkg{sos4R} can help enabling this.

The project is part of the geostatistics community\footnote{\url{http://52north.org/communities/geostatistics/}} of the \fivetwon Initiative for Geospatial Open Source Software\footnote{\url{http://52north.org/}}. \pkg{sos4R} is available, or will be available soon, on CRAN.

On the package home page, \url{http://www.nordholmen.net/sos4r/}, you can stay updated with the development blog, find example code and services, and download source packages.

This software is released under a GPL~2 license\footnote{\url{http://www.gnu.org/licenses/gpl-2.0.html}} and contributions are very welcome. Please consult section~\ref{sec:developing} for details.

The package \pkg{sos4R} is loaded by 
<<load,echo=TRUE,print=FALSE>>= 
library("sos4R")
@

This document was build for \textbf{package version \Sexpr{sessionInfo()[["otherPkgs"]][["sos4R"]][["Version"]]}}.

\subsection{Related Specifications}

The Open Geospatial Consortium\footnote{\url{http://www.opengeospatial.org/}} (OGC) is an organisation which provides standards for handling geospatial data on the internet, thereby ensuring interoperability.

The Sensor Observation Service (SOS) is such a standard and provides a well-defined interface for data warehousing of measurements and observations made by all kinds of sensors. This vignette describes the classes, methods and functions provided by \pkg{sos4R} to query these observations.

Storing and providing data in web services is more powerful than local file copies (with issues like outdating, redundancy, \ldots). Flexible filtering of data on the service side reduces download size. That is why SOS operations can comprise flexible subsetting in temporal, spatial and thematical domain. For example \enquote{Provide only measurements from sensor MySensor-001 for the time period from 01/12/2010 to 31/12/2010 where the air temperature below zero degrees}.

In general, the SOS supports two methods of requesting data: (i) HTTP GET as defined in the OOSTethys best practice document\footnote{\url{http://www.oostethys.org/best-practices/best-practices-get}}, and (ii) POST as defined in the standard document. Both request types always returns eXtensible Markup Language (XML) documents as response.

Standards that are referenced, respectively used, by SOS are as follows.

\begin{description}
\item[Observations and Measurements (O\&M)] O\&M (Cox, 2007) defines the markup of sensor measurements results. An observation consists of information about the observerd geographic feature, the time of observation, the sensor, the observed phenomenon, and the observation's actual result.
\item[Sensor Model Language (SensorML)] SensorML (Botts, 2007) is used for sensor metadata descriptions (calibration information, inputs and outputs, maintainer).
\item[Geography Markup Language (GML)] (Portele, 2003) defines markup for geographical features (points, lines, polygons, \ldots).
\item[SweCommon] SWE Common describes data markup and is contained in the SensorML specification.
\item[Filter Encoding] Filter Encoding (Vretanos, 2005) defines operators and operands for filtering values.
\item[OWS Common] OGC Web Services Common (Whiteside, 2007) models service related elements that are reusable across several service specifications, like excheption handling.
\end{description}

\subsection{Terms and Definitions}

The OGC has a particular set of well-defined terms that might differ from usage of words in specific domains. The most important are as follows\footnote{Based on \url{http://de.wikipedia.org/wiki/Sensor_Observation_Service}}.

\begin{description}
\item[Feature of Interest (FOI)] The FOI represents the geo-object, for which measurements are made by sensors. It is ordinarily used for the spatial referencing of measuring points, i.e. the geoobject has coordinates like latitude, longitude and height. The feature is project specific and can be anything from a point (e.g. the position of a measuring station) or a real-world object (e.g. the region that is observed).
\item[Observation] The observation delivers a measurement (result) for a property (phenomenon) of an observed object (FOI). The actual value is created by a sensor or procedure. The phenomenon was measured at a specific time (sampling time) and the value was generated at a specific point in time (result time). These often coincide so in practice the sampling time is often used as the point in time of an obsrevation.
\item[Offering] The offering is a logical collection of related observations (similar to a layer in mapping applications) which a service offers together.
\item[Phenomenon] A phenomenon is a property (physical value) of a geographical object, e.g. air temperature, wind speed, concentration of a pollutant in the athmosephere, reflected radiation in a specific frequency band (colours).
\item[Procedure] A procedure creates the measurement value of an observation. The source can be a reading from a sensor, simulation or a numerical process.
\end{description}

A more extensive discussion is available in the the O\&M specification (Cox, 2007). The Annex B of that document shows the following examples of applicating some terms to a specific domain, earth observations, which are repeated here for elaboration.

\begin{tiny}
\begin{tabular}{ l || c | r | }
  O\&M & Particulate Matter 2.5 Concentrations & EO \\
  \hline
  Observation::result & 35 ug/m3 & observation value, measurement value \\
  Observation::procedure & U.S. EPA Federal Reference Method for PM 2.5 & method, sensor \\
  Observation::observedProperty & Particulate Matter 2.5 & parameter, variable \\
  Observation::featureOfInterest & troposphere & media (air, water, \ldots) & Global Change Master Directory "Topic" \\
\end{tabular}
\end{tiny}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Supported Features}
\label{sec:supported}

The package provides accessor functions for the supported parameters. It is recommended to access options from the lists returned by these functions instead of hardcoding them into scripts.

<<supported,echo=TRUE,print=TRUE>>=
SosSupportedOperations()
SosSupportedServiceVersions()
SosSupportedConnectionMethods()
SosSupportedResponseFormats()
SosSupportedResponseModes()
SosSupportedResultModels()
@

<<supported,echo=TRUE,eval=FALSE>>=
SosSupportedSpatialOperators()
@
<<supported,echo=FALSE,eval=TRUE,print=TRUE>>=
print(SosSupportedSpatialOperators())
@

<<supported,echo=TRUE,eval=FALSE>>=
SosSupportedTemporalOperators()
@
<<supported,echo=FALSE,eval=TRUE,print=TRUE>>=
print(SosSupportedTemporalOperators())
@


\subsection{Supported Services and Implementations}

\pkg{sos4R} supports the core profile of the SOS specification. But the possible markups for observations is extremely manifold due to the flexibility of the O\&M specification. Sadly, there is no common application profile for certain types of observations, like simple measurements.

Therefore, the undocumented profile of the \textbf{\fivetwon SOS implementation}\footnote{\url{http://52north.org/communities/sensorweb/sos/}} was used as a guideline. It is not documented outside of the source code. Observations returned by instances of this implementation are most likely to be processed out of the box.

In the author's experience, \textbf{OOSThetys SOS implementations}\footnote{\url{http://www.oostethys.org/}} utilize the same or at least very similar profile, so responses of these service instances are also probably parsed without further work.

Please share your experiences with other SOS implementations with the developers and users of \pkg{sos4R} (see section \ref{\label{sec:support}}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Default Options}
\label{sec:default}

Two kinds of default values can be found in (function calls in) \pkg{sos4R}: (i) default depending on other function parameters, and (ii) global defaults. Global defaults can be inspected (not set!) using the following functions. If you want to use a different value please adapt the respective argument in function calls.

<<default,echo=TRUE,print=TRUE>>=
SosDefaultConnectionMethod()
SosDefaults()
@

The process of data download also comprises (i) building requests, (ii) decoding responses, and (iii) applying the correct R data type to the respective data values. This mechanism is explained in detail in see section \ref{sec:exchangeability}. The package comes with a set of predefined encoders, decoders and converters.

<<converterFunc,echo=TRUE,eval=FALSE>>=
SosEncodingFunctions()
SosParsingFunctions()
SosDataFieldConvertingFunctions()
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Creating a SOS connection}

The operation \code{SOS(...)} is a construction method for classes encapsulating a connection to a SOS. It prints out a short statement when the connection was successful and returns an object of class \code{SOS}.

<<conn,echo=TRUE,print=FALSE>>= 
mySOS = SOS(url = "http://v-swe.uni-muenster.de:8080/WeatherSOS/sos")
@

To create a SOS connection you only need the URL of the service (i.e. the URL which can be used for HTTP GET or POST requests).

The optional parameters use default settings (see section \ref{sec:default}):
 
\begin{itemize}
    \item \code{method}: The transport protocol. Currently available are \Sexpr{names(SosSupportedConnectionMethods())}.
    \item \code{version}: The service version. Currently allowed are  Currenlty available are \Sexpr{SosSupportedServiceVersions()}.
    \item \code{parsers}: The list of parsing functions. See section \ref{subsec:parsers}.
    \item \code{encoders}: The list of encoding functions. See section \ref{subsec:encoders}.
    \item \code{dataFieldConverters}:  The list of conversion functions. See section \ref{subsec:converters}.
    \item \code{curlHandle}, \code{curlOptions}: Settings of the package \pkg{RCurl}, which is used for HTTP connections. Please consult the packags specification before using this.
    \item \code{timeFormat}: The time format to be used or decoding and encoding time character strings to and from \code{POSIXt} classes.
    \item \code{verboseOutput}: Trigger parameter for extensive debugging information on the console, see section \ref{subsec:verbose}.
\end{itemize}

There are accessor methods for the slots of the class.

<<connDetails1,echo=TRUE,eval=TRUE>>= 
sosUrl(mySOS)
sosVersion(mySOS)
sosTimeFormat(mySOS)
sosMethod(mySOS)
@

The following slots are best described in section \ref{sec:exchangeability}.

<<connDetails2,echo=TRUE,eval=FALSE>>= 
sosParsers(mySOS)
# Print out the element names for which the parsing functions are registered:
#names(sosParsers(mySOS))
@

<<connDetails4,echo=TRUE,eval=FALSE>>= 
sosDataFieldConverters(mySOS)
# Print out the elements for which the conversion functions are registered:
#names(sosDataFieldConverters(mySOS))
@

The default connection method is HTTP POST, but since not all SOS support this a GET connection is possible was well. The latter is partly limited, for example regarding filtering operations. Section~\ref{subsec:converters} contains an example of such a connection.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{SOS Operations}

\pkg{sos4R} implements the SOS core profile of version 1.0.0 comprising the operations GetCapabilities, DescribeSensor and GetObservation. This document focusses on the practical usage of the operations, so the reader is refered to the specification document for details.

The methods mirroring the SOS operations all contain debugging parameters \code{inspect} and \code{verbose} as described in section \ref{subsec:inspect}.

\subsection{GetCapabilities}

The GetCapabilities operations is automatically conducted during the connecting to a SOS instance. If you want to inspect the original capabilities document it can be re-requested using

<<capsOriginal,echo=TRUE,eval=FALSE>>= 
sosCapabilitiesDocumentOriginal(sos = mySOS)
@

The actual operation can be started with the following function. It returns an object of class \code{SosCapabilities} which can be accessed later on by the function \code{sosCaps()} from an object of class \code{SOS}.

<<getCap,echo=TRUE,eval=FALSE>>= 
getCapabilities(sos = mySOS)
@

\begin{itemize}
    \item \code{sos}: The SOS connection to request the capabilities document from.
    \item \code{inspect} and \code{verbose}: See section \ref{subsec:inspect}.
\end{itemize}


\subsection{DescribeSensor}

The DescribeSensor operation is specified in clause 8.3 of the SOS specification and their response is modeled in Sensor Model Language\footnote{http://www.opengeospatial.org/standards/sensorml} (SensorML) and Transducer Markup Language\footnote{http://www.opengeospatial.org/standards/tml} (TML) specifications.

\begin{quotation}
The DescribeSensor operation is useful for obtaining detailed information of sensor characteristics encoded in either SensorML or TML. The sensor characteristics can include lists and definitions of observables supported by the sensor. [...]
\end{quotation}

The parameters of the operation are the following:

\begin{itemize}
    \item \code{sos}: The SOS connection to request a sensor description from.
    \item \code{procedure}: The identifier of the sensor, so one of the character strings returned by \code{sosProcedures(...)}.
    \item \code{outputFormat}: The format in which the sensor description is to be returned by the service. The default value is $\Sexpr{sosDefaultDescribeSensorOutputFormat}$.
    \item \code{inspect} and \code{verbose}: See section \ref{subsec:inspect}.
\end{itemize}

<<describeSensor,echo=TRUE,print=TRUE>>= 
sensor.1.1 <- describeSensor(sos = mySOS,
		procedure = sosProcedures(obj = mySOS)[[1]][[1]])
# Inspect complete sensor description document:
#sensor.1.1@xml
@

\subsection{GetObservation}

A few utility functions exist to minize a user's amount of work to create usual requests. They accept normal R types as input and return the respective class from \pkg{sos4R} with useful default settings. These function's names start with \code{sosCreate...()} and exist for spatial and temporal filters.

In this section, all matters around requesting data are explained --- from extracting query parameters from metadata, and sending the request, till finally extracting data values and coordinates from the response.

\subsubsection{Metadata Extraction for Request Building}

How can one extract the metadata from a SOS connection and reuse it for queries?

accessor functions, elements of the capabilities, ...

TODO: jedes statement einzeln und erklaeren...

<<metadataExtraction,echo=TRUE,eval=TRUE>>= 
sosContents(mySOS)
@

<<metadataExtraction,echo=TRUE,eval=TRUE,print=TRUE>>= 
sosFilter_Capabilities(mySOS)
sosServiceIdentification(mySOS)
sosServiceProvider(mySOS)

#sosOfferings(mySOS)
off.temp <- sosOfferings(mySOS)[["ATMOSPHERIC_TEMPERATURE"]]
# the order of offerings can change in between requests

sosOfferingIds(mySOS)
# Names of offerings list are the Ids (same output as last call)
# names(sosOfferings(mySOS))
sosId(off.temp)
sosOfferings(mySOS)[1:2]

sosProcedures(mySOS)
sosProcedures(off.temp)
# the order of procedures can change in between requests

sosObservedProperties(mySOS)
sosObservedProperties(off.temp)
# the order of observed properties can change in between requests

sosBoundedBy(off.temp)
str(sosBoundedBy(off.temp)) # Nicht so schön ...

sosTime(mySOS)
off.temp.time <- sosTime(off.temp)
str(off.temp.time)
# "wirklichen" Startzeitpunkt abfragen
off.temp.time@beginPosition@time
class(off.temp.time@beginPosition@time)
@
 

\subsubsection{Basic Request and Result Extraction}

<<getObservation,eval=FALSE,echo=TRUE>>= 
getObservation(sos = mySOS, ...)
@

\begin{itemize}
%\item \verb|[| select "rows" (items) and/or columns in the data attribute
%table; e.g. {\tt meuse[1:2, "zinc"]} returns a {\tt SpatialPointsDataFrame}
%with the first two points and an attribute table with only variable "zinc".
%\item \verb|[[| select a column from the data attribute table
  \item \code{latest}: A boolean parameter to request the latest observation only (see example below) --- this is not standard conform.
\end{itemize}

A request to retrieve the latest measured value is also possible, although not (!) standard conform. \fivetwon SOS realizes this specific request by requesting a sampling time with the fixed value \enquote{latest}.

<<getLatest,eval=TRUE,echo=TRUE>>= 
obs.temp.latest <- getObservation(sos = mySOS, offering = off.temp,
		latest = TRUE)
@

The returned data is an XML document of type om:Observation, om:Measurement, or om:ObservationCollection which holds a list of the former two. All three of these have corresponding S4 classes, namely \code{OmObservation}, \code{OmMeasurement}, or \code{OmObservationCollection}.

\textbf{Result subsetting} of elements in an \code{OmObservationCollection} can be done just like in a normal list (in fact, it just wraps at list of observations at this point), i.e. with the operators \code{[} and \code{[[}.

<<getObs1,eval=TRUE,echo=TRUE>>=
length(obs.temp.latest)
obs.temp.latest[[1]]
obs.temp.latest[2:3]
@

Addionally, indexing is also possible via procedure, observed property, and feature of interest identifiers.

<<getObs1,eval=FALSE,echo=TRUE>>=
index.foiId <- sosFeatureIds(obs.temp.latest)[[1]]
obs.temp.latest[index.foiId]

index.obsProp <- sosObservedProperties(off.temp)
obs.temp.latest[index.obsProp]

index.proc <- sosProcedures(obs.temp.latest)[1:4]
index.proc.alternative <- sosProcedures(off.temp)[1:4]
#index.proc.alternative <- sosProcedures(mySOS)
obs.temp.latest[index.proc]
@

\textbf{Data Values} can be extracted from observations and observation collections with the function \code{sosResult(...)}.  The function returns an object of class \code{data.frame}. In the case of collections, it automatically binds the data frames (you can turn this off by adding \code{bind = FALSE} as a parameter). Additional metadata, like units or definitions, is accessible via \code{attributes(...)} for every column of the data frame. 

<<getObs2,eval=FALSE,echo=TRUE>>= 
obs.temp.latest.result.2 <- sosResult(obs.temp.latest[[2]])
obs.temp.latest.result <- sosResult(obs.temp.latest[1:2])

temperature.attrs <- attributes(obs.temp.latest.result[["urn:ogc:def:property:OGC::Temperature"]])
@

\textbf{Spatial Information} can be stored in an observation in several ways: (i) as a usual data attribute which is directly contained in the result \code{data.frame}, (ii) within a feature collection in the observation. In the latter case the utility functions \code{sosCoordinates(...)} and \code{sosFeatureIds(...)} can be used to extract the coordinates respectively the identifiers from \code{OmObservationCollection} or \code{OmObservation} classes. A variety of feature types gml:Point or sa:SamplingPoint are supported by \code{sosCoordinates(...)}.

<<getObsSpatial1,eval=TRUE,echo=TRUE>>= 
obs.temp.latest.foiIDs <- sosFeatureIds(obs.temp.latest)
obs.temp.latest.coordinates.all <- sosCoordinates(obs.temp.latest)
obs.temp.latest.coordinates.1 <- sosCoordinates(obs.temp.latest[[1]])
@

An observation collection also contains a bounding box of the contained observations, which can be extracted with the function \code{sosBoundedBy(...)}. The 

<<getObsSpatial1,eval=TRUE,echo=TRUE>>= 
sosBoundedBy(obs.temp.latest)
@

The combination of data values and coordinates strongly depends on the use case and existing spatial information. In the case of coordinates encoded in the features, a matching of the two data frames can easily be accomplished with the function \code{merge()}.

<<getObsSpatial2,eval=FALSE,echo=TRUE>>= 
obs.temp.latest.coords <- sosCoordinates(obs.temp.latest)
obs.temp.latest.data <- merge(x = obs.temp.latest.result,
		y = obs.temp.latest.coords)
obs.temp.latest.data
@

The default column name for the feature identifiers is \code{\Sexpr{sosDefaultColumnNameFeatureIdentifier}}. If the name of the feature identifier attribute in the data table matches (which is the case for \fivetwon SOS), \code{merge} does not need additional information. In that case, the merging reduces to the following simple code.

<<getObsSpatial3,eval=FALSE,echo=TRUE>>= 
names(obs.temp.latest.result)
names(obs.temp.latest.coords)
obs.temp.latest.coords <- sosCoordinates(obs.temp.latest)
obs.temp.latest.data <- merge(x = obs.temp.latest.result,
		y = obs.temp.latest.coords)
obs.temp.latest.data
@

In that case, you can even save that step by specifying the attribute \code{coordinates} of the function \code{sosResult} which includes the merge of data values and coordinates.

<<getObsSpatial4,eval=FALSE,echo=FALSE,print=FALSE>>= 
sosResult(obs.temp.latest, coordinates = TRUE)
@

\subsubsection{Temporal Filtering}

The possibly most typical temporal filter is a period of time for which measurements are of interest.

<<temporalFiltering1,eval=TRUE,echo=TRUE>>= 
# temporal interval creation based on POSIXt classes 
lastWeek.period <- sosCreateTimePeriod(sos = mySOS,
		begin = (Sys.time() - 3600 * 24 * 7), end = Sys.time())
lastWeek.eventTime <- sosCreateEventTimeList(lastWeek.period)
@

Please note that the create function also wraps the created objects in a list as expected by the method \code{getObservation(...)}.

What was the average temperature during the last week?
		
<<temporalFiltering2,eval=TRUE,echo=TRUE>>= 
obs.lastWeek <- getObservation(sos = mySOS, offering = off.temp,
		procedure = sosProcedures(off.temp), eventTime = lastWeek.eventTime)

obs.temp.lastWeek.result <- sosResult(obs.lastWeek)
summary(obs.temp.lastWeek.result)[4,"urn:ogc:def:property:OGC::Temperature"]
@

The default temporal operator is \enquote{during}, but others are supported as well (see section \ref{sec:supported}). The next example shows how to create a temporal filter for all observations taken \textbf{after} a certain point in time. Here the creation function creates just one object of class \code{SosEventTime} which must be added to a list manually before passing it to \code{getObservation(...)}.

<<temporalFiltering3,eval=TRUE,echo=TRUE>>=
lastDay.instant <- sosCreateTimeInstant(
		time = as.POSIXct(Sys.time() - 3600 * 24), sos = mySOS)
lastDay.eventTime <- sosCreateEventTime(time = lastDay.instant,
		operator = SosSupportedTemporalOperators()[["TM_After"]])
print(lastDay.eventTime)
#print(encodeXML(obj = lastDay.eventTime[[1]], sos = mySOS))
@

\subsubsection{Spatial Filtering}

The possibly most typical spatial filter is a bounding box\footnote{\url{http://en.wikipedia.org/wiki/Bounding_box}} within which measurements of interest must have been made. Here the creation function returns an object of class \code{OgcBBOX}, which can be wrapped in an object of class \code{SosFeatureOfInterest}, which is passed into the get-observation call.

<<spatialFiltering1,eval=TRUE,echo=TRUE>>=
request.bbox <- sosCreateBBOX(lowLat = 10.0, lowLon = 2.0,
		uppLat = 50.0, uppLon = 15.0, srsName = "urn:ogc:def:crs:EPSG:4326")
request.bbox.foi <- sosCreateFeatureOfInterest(spatialOps = request.bbox)

obs.lastWeek.bbox <- getObservation(sos = mySOS,
		offering = off.temp,
		featureOfInterest = request.bbox.foi,
		eventTime = list(lastDay.eventTime))
print(sosCoordinates(obs.lastWeek.bbox))
@

More advanced spatial filtering, for example based on arbitrary shapes et cetera, is currently not implemented. This could be implemented by implementing subclasses for \code{GmlGeometry} (including encoders) which must be wrapped in \code{OgcBinarySpatialOp} which extends \code{OgcSpatialOps} and can therefore be added to an object of class \code{SosFeatureOfInterest} as the spatial parameter.

\subsubsection{Feature Filtering}

The feature can not only be used for spatial filtering, but also to query specific FOIs. The following example extracts the identifiers from an offering and then creates an object of class \code{SosFeatureOfInterest}, which is passed into the get-observation call.

<<featureFiltering1,eval=TRUE,echo=TRUE>>= 
off.temp.fois <- sosFeaturesOfInterest(off.temp)
request.fois <- sosCreateFeatureOfInterest(
		objectIDs = list(off.temp.fois[[1]]))
encodeXML(obj = request.fois, sos = mySOS)
@

<<featureFiltering1,eval=TRUE,echo=TRUE,print=FALSE>>= 
obs.lastWeek.fois <- getObservation(sos = mySOS, offering = off.temp,
		featureOfInterest = request.fois, eventTime = lastWeek.eventTime)
print(sosFeaturesOfInterest(obs.lastWeek.fois))
@


\subsubsection{Value Filtering}

Value Filtering is realized via the slot \code{result} in a GetObservation request. The filtering in the request is based on comparison operators and operands specified by OGC Filter Encoding (Vretanos, 2005).

The classes and methods of this specification are not yet implemented, but manual definition of the XML elements is possible with the methods of the package \pkg{XML}.

The following code example uses a literal comparison of a property:

<<valueFiltering1,eval=TRUE,echo=TRUE>>= 
# result filtering
filter.value <- -2.3
filter.propertyname <- xmlNode(name = ogcPropertyNameName,
		namespace = ogcNamespacePrefix)
xmlValue(filter.propertyname) <- "urn:ogc:def:property:OGC::Temperature"
filter.literal <- xmlNode(name = "Literal", namespace = ogcNamespacePrefix)
xmlValue(filter.literal) <- as.character(filter.value)
filter.comparisonop <- xmlNode(name = ogcComparisonOpGreaterThanName,
		namespace = ogcNamespacePrefix,
		.children = list(filter.propertyname, filter.literal))
filter.result <- xmlNode(name = sosResultName, namespace = sosNamespacePrefix,
		.children = list(filter.comparisonop))
@

Please consult to the extensive documentation of the \pkg{XML} package for details. The commands above result in the following output which is inserted into the request without further processing.

<<valueFiltering2,eval=TRUE,echo=TRUE,print=TRUE>>= 
print(filter.result)
@

Any object of class \code{OgcComparisonOpsOrXMLOrNULL}, which includes the class of the object returned by \code{xmlNode(...)}, i.e. \code{XMLNode}. These object can be used in the GetObservation request as the \code{result} parameter.

First, we request the unfiltered values for comparison, then again with the filter applied. The length of the returned results is compared in the end.

<<valueFiltering3,eval=TRUE,echo=TRUE,print=TRUE>>= 
# request  values for the last week.
obs.lastWeek <- getObservation(sos = mySOS,
		eventTime = lastWeek.eventTime,
		offering = sosOfferings(mySOS)[["ATMOSPHERIC_TEMPERATURE"]])

# request  values for the week with a value higher than 0 degrees.
obs.lastWeek.filter <- getObservation(sos = mySOS,
		eventTime = lastWeek.eventTime,
		offering = sosOfferings(mySOS)[["ATMOSPHERIC_TEMPERATURE"]],
		result = filter.result)
paste("Filtered:", dim(sosResult(obs.lastWeek.filter))[[1]], 
				"-vs.- Unfiltered:", dim(sosResult(obs.lastWeek))[[1]])
@

\subsubsection{Result Exporting}

A tighter integration with data structures of packages \pkg{sp} or \pkg{spacetime} (both available on CRAN) is planned for the future. Please consult the developers for the current status.

As an example the following code creates a \code{SpatialPointsDataFrame} (can only contain one data value per position!) based on the features of a result.

<<resultExporting,eval=TRUE,echo=TRUE,print=FALSE>>=
library("sp")
obs.lastWeek <- getObservation(sos = mySOS,
		offering = off.temp,
		procedure = sosProcedures(off.temp),
		eventTime = lastWeek.eventTime)

# Create SpatialPointsDataFrame from result features
coords <- sosCoordinates(obs.lastWeek[[1]])
crs <- sosGetCRS(obs.lastWeek[[1]])
spdf <- SpatialPointsDataFrame(coords = coords[,1:2],
		data = data.frame(coords[,4]), proj4string = crs)
str(spdf)
@

\subsection{GetObservationById}

The operation GetObservationById is defined in clause 10.1 of the SOS specification and not part of the core profile. But it is implemented as it is quite simple. The response is the same as described in the previous section. Optional parameters are the same as in GetObservation requests.

<<getObsById,eval=FALSE,echo=TRUE>>= 
obs <- getObservationById(sos = mySOS, observationId = "o00001")
obs
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Changing Handling Functions}
\label{sec:exchangeability}

TODO: explain approach, mention available non-exchangeable functions in the subsections

fixed order, exchangeable components

explain include/exclude mechanism


The process of data download also comprises (i) building requests, (ii) decoding responses, and (iii) applying the correct R data type to the respective data values. This mechanism is explained in detail in see section \ref{subsec:converters}.


\subsection{Parsers/Decoders}
\label{subsec:parsers}

The terms parsing and decoding are used as names for the process of processing an XML document to create an R object.

TBD

\subsection{Encoders}
\label{subsec:encoders}

TBD

\subsection{Data Converters}
\label{subsec:converters}

A list of named functions to be used by the parsing methods to convert data values to the correct R type, which are mostly based on the unit of measurement\footnote{\url{http://en.wikipedia.org/wiki/Units_of_measurement}} code.

The conversion functions always take two parameters: \code{x} is the object to be converted, \code{sos} is the service where the request was received from.

The available functions are basically wrappers for coercion functions, for example \code{as.double()}. The only method exploiting the second argument is the one for conversion of time stamps which uses the time format saved with the object of class \code{SOS} in a call to \code{strptime}.

<<converters0,eval=TRUE,echo=FALSE,print=TRUE>>= 
value <- 2.0
value.string <- sosConvertString(x = value, sos = mySOS)
print(class(value.string))

value <- "2.0"
value.double <- sosConvertDouble(x = value, sos = mySOS)
print(class(value.double))

value <- "1"
value.logical <- sosConvertLogical(x = value, sos = mySOS)
print(class(value.logical))

value <- "2010-01-01T12:00:00.000"
value.time <- sosConvertTime(x = value, sos = mySOS)
print(class(value.time))
@

The full list of currently supported units can be seen below. It mostly contains common numerical units which are converted to type \code{double}.

<<converters1,echo=FALSE,print=TRUE>>=
names(SosDataFieldConvertingFunctions())
@

The following connection shows a typical workflow of connecting to a new SOS for the first time, what the errors for missing converters look like, and how to add them to the SOS connection.

<<converters2,eval=TRUE,echo=TRUE>>= 
# GET Verbindung
MBARI <- SOS("http://mmisw.org/oostethys/sos",
		method = SosSupportedConnectionMethods()[["GET"]])
myOff <- sosOfferings(MBARI)[[1]]
myProc <- sosProcedures(MBARI)[[1]]
mbariObs1 <- try(getObservation(sos = MBARI, offering = myOff,
				procedure = myProc))
warnings()
@

There are warnings about unknown units of measurement. The example below creates conversion functions for these and subsequently results in more fields in the final result.

<<converters3,eval=TRUE,echo=TRUE,print=FALSE>>= 
# Create converters for missing units and definitions, then reconnect:
myConverters <- SosDataFieldConvertingFunctions(
		"S/m" = sosConvertDouble,
		"http://mmisw.org/ont/cf/parameter/sea_water_salinity" = sosConvertDouble)
MBARI <- SOS("http://mmisw.org/oostethys/sos",
		method = SosSupportedConnectionMethods()[["GET"]],
		dataFieldConverters = myConverters)
mbariObs2 <- getObservation(sos = MBARI, offering = myOff, procedure = myProc)
@

<<converters4,eval=TRUE,echo=TRUE,print=TRUE>>= 
names(sosResult(mbariObs1))
names(sosResult(mbariObs2))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exception Handling}
\label{sec:exception}

When working with sos4R, two kinds of errors must be handled: service exceptions and package errors. The former can occur when a request is invalid or a service encounters internal exceptions. The latter can mean a bug or illegal settings within the package. To understand both types of errorenous states, this sections explains the contents of the exception reports returned by the service and the functionalities to investigate the inner workings of the package.

\subsection{OWS Service Exceptions}

The service exceptions returned by a SOS are described in OGC Web Services Common (Whiteside, 2007) clause 8. The classes to handle the returned exceptions in sos4R are \code{OwsExceptionReport}, which contains a list of exception reports,  and \code{OwsException}, which contains slots for the parameters exception text(s), exception code, and locator. These are defined as follows and can be implementation specific.

\begin{description}
\item[ExceptionText] Text describing specific exception represented by the exceptionCode.
\item[exceptionCode] Code representing type of this exception.
\item[locator] Indicator of location in the client's operation request where this exception was encountered.
\end{description}

The standard exception codes and meanings are accessible by calling 

<<exceptionData,eval=FALSE,echo=TRUE>>= 
OwsExceptionsData()
@

directly in \pkg{sos4R} and are shown in table \ref{tab:execptions}.

<<exceptionTable,echo=FALSE,results=tex>>=
library(xtable)
print(xtable(x = OwsExceptionsData(), caption = "Exception Data Table", label = "tab:execptions", table.placement = "tbp", caption.placement = "top"))
@

<<exceptionWarning,eval=TRUE,echo=TRUE,print=TRUE>>= 
response <- try(getObservationById(sos = mySOS, observationId = "doesNotExist"))
@

If an exception is received then it is also saved as a warning message.


\subsection{Inspect Requests and Verbose Printing}
\label{subsec:inspect}
\label{subsec:verbose}

The package offers two levels of inspection of the ongoing operations indicated by two boolean parameters, \code{inspect} and \code{verbose}. These are available in all service operation calls. The option \code{verboseOutput} when using the method \code{SOS(...)} turns on the verbose setting for all subsequent requests made to the created connection unless deactivated in an operation call.

\begin{description}
\item[inspect] prints the raw requests and responses to the console. An example is shown below.
\item[verbose] prints not only the requests, but also debugging statements which are too extensive to show for this document.
\end{description}

<<inspect,eval=TRUE,echo=TRUE>>= 
off1 <- sosOfferings(mySOS)[[1]]
getObservation(sos = mySOS,
		offering = off1, latest = TRUE,
		procedure = sosProcedures(off1)[[1]],
		inspect = TRUE)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Getting Started}

The \textbf{demos} are a good way to get started with the package. Please be aware that the used SOSs might be temporarily unavailable.

<<demo,echo=TRUE,eval=FALSE>>= 
demo(package = "sos4R")
@

Additionally, there is a list of services on the project homepage (\url{http://www.nordholmen.net/sos4r/data/}) and a few SOS URLs are available via the function \texttt{SosExampleServices()}.

<<exampleServices,echo=TRUE,print=TRUE>>= 
SosExampleServices()
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Getting Support}
\label{sec:support}

If you want to ask questions about using the software, please go first to the \fivetwon \textbf{forum} for the geostatistics community at \url{http://geostatistics.forum.52north.org/} and check if a solution is described there. If you are a frequent user please consider subscribing to the geostatistics \textbf{mailing list} (\url{http://list.52north.org/mailman/listinfo/geostatistics}) which is linked to the forum.

\section{Developing sos4R}
\label{sec:developing}

\subsection*{Code Repository}

You can download (and also browse) the source code of \pkg{sos4R} directly from the \fivetwon repository:

\begin{itemize}
\item \textbf{SVN resource URL}: \url{https://svn.52north.org/svn/geostatistics/main/sos4R}. Please read the documentation (especially the posting guide) of the \fivetwon repositories\footnote{http://52north.org/resources/source-repositories/}. Anonymous access for download is possible.
\item \textbf{Web access}: \url{https://svn.52north.org/cgi-bin/viewvc.cgi/main/sos4R/?root=geostatistics}
\end{itemize}

See the \textbf{developer documentation} at the \fivetwon Wiki for detailed information on how to use the checked out source project: \url{https://wiki.52north.org/bin/view/Geostatistics/Sos4R }. You will find a detailed description of the folder and class structure, the file naming scheme, and an extensive list of tasks for future development.

Please get in touch with the community lead\footnote{\url{http://52north.org/communities/geostatistics/community-contact}} of the geostatistics community if you want to \textbf{become a contributor}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgements}

The project was generously supported by the \fivetwon Student Innovation Prize for Geoinformatics 2010. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}

\begin{description}
\item Botts, M., 2007, OGC Implementation Specification 07-000: OpenGIS Sensor Model Language (SensorML)- Open Geospatial Consortium, Tech. Rep.
\item Chambers, J.M., 2008, Software for Data Analysis, Programming with R. Springer, New York.
\item Cox, S., 2007, OGC Implementation Specification 07-022r1: Observations and Measurements - Part 1 - Observation schema. Open Geospatial Consortium. Tech. Rep.
\item Cox, S., 2007, OGC Implementation Specification 07-022r3: Observations and Measurements - Part 2 - Sampling Features. Open Geospatial Consortium. Tech. Rep.
\item Na, A., Priest, M., Niedzwiadek, H. and Davidson, J., 2007, OGC Implementation Specification 06-009r6: Sensor Observation Service, \url{http://portal.opengeospatial.org/files/?artifact_id=26667}, Open Geospatial Consortium, Tech. Rep. 
\item Portele, C., 2003, OGC Implementation Specification 07-036: OpenGIS Geography Markup Language (GML) Encoding Standard, version: 3.00. Open Geospatial Consortium, Tech. Rep.
\item Vretanos, P.A., 2005, OGC Implementation Specification 04-095: OpenGIS Filter Encoding Implementation Specification. Open Geospatial Consortium, Tech. Rep.
\item Whiteside, A., Greenwood, J., 2008, OGC Implementation Specification 06-121r9: OGC Web Services Common Specification. Open Geospatial Consortium, Tech. Rep.
\end{description}

\end{document}